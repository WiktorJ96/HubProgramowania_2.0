<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Performance Monitoring i Tuning</title>
  <link rel="stylesheet" href="../styles.css" />
  <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
</head>
<body>
  <div class="container">
    <h1>Performance Monitoring i Tuning</h1>

    <p>
      <strong>Monitoring</strong> to mierzenie i obserwacja (co boli i gdzie), a <strong>tuning</strong> to leczenie (zmiany w zapytaniach/indeksach/konfiguracji).
    </p>

    <div class="note">
      <strong>Analogia:</strong> Serwer bazy to auto. Monitoring to „zegar spalania, obroty, temperatura”, a tuning to „regulacja mieszanki, wymiana filtra, lżejsze koła” – najpierw <em>mierz</em>, potem <em>zmieniaj</em>.
    </div>

    <!-- ===================== NARZĘDZIA MONITORUJĄCE ===================== -->
    <h2>Narzędzia monitorujące</h2>

    <h3>MySQL Performance Schema</h3>
    <p>Wbudowany mechanizm rejestrujący statystyki zapytań, oczekiwań i zdarzeń.</p>

    <pre><code class="language-ini"># my.cnf – włączenie Performance Schema
[mysqld]
performance_schema = ON</code></pre>

    <pre><code class="language-sql">-- Najcięższe zapytania (po łącznym czasie)
SELECT
  EVENT_NAME,
  COUNT_STAR                 AS liczba_wywołań,
  SUM_TIMER_WAIT/1e12       AS czas_s,         -- ns → s
  AVG_TIMER_WAIT/1e6        AS avg_ms          -- ns → ms
FROM performance_schema.events_statements_summary_by_digest
ORDER BY SUM_TIMER_WAIT DESC
LIMIT 10;</code></pre>

    <details open>
      <summary class="table-title">Wizualizacja wyników (przykładowo)</summary>
      <table class="db-table">
        <thead><tr><th>EVENT_NAME / DIGEST_TEXT (skrót)</th><th>liczba_wywołań</th><th>czas_s</th><th>avg_ms</th></tr></thead>
        <tbody>
          <tr><td>SELECT FROM orders WHERE ...</td><td>120k</td><td>950</td><td>7.9</td></tr>
          <tr><td>UPDATE order_items SET ...</td><td>34k</td><td>320</td><td>9.4</td></tr>
        </tbody>
      </table>
      <p class="mini">Cel: wyłap „Top N” najdroższych zapytań i optymalizuj je w pierwszej kolejności.</p>
    </details>

    <h3>PostgreSQL pg_stat_statements</h3>
    <p>Rozszerzenie zbiera statystyki wykonania zapytań (liczba wywołań, czas, odchylenie, bufory itp.).</p>

    <pre><code class="language-ini"># postgresql.conf – włączenie
shared_preload_libraries = 'pg_stat_statements'

# po restarcie serwera (raz per baza):
-- SQL:
CREATE EXTENSION pg_stat_statements;</code></pre>

    <pre><code class="language-sql">-- Najdroższe zapytania (po łącznym czasie)
SELECT
  query,
  calls                         AS liczba_wywołań,
  round(total_time/calls, 2)    AS avg_ms,
  round(total_time, 2)          AS total_ms
FROM pg_stat_statements
ORDER BY total_time DESC
LIMIT 10;</code></pre>

    <details>
      <summary class="table-title">Wizualizacja wyników (przykładowo)</summary>
      <table class="db-table">
        <thead><tr><th>query (skrót)</th><th>liczba_wywołań</th><th>avg_ms</th><th>total_ms</th></tr></thead>
        <tbody>
          <tr><td>SELECT p.* FROM products p WHERE ...</td><td>250k</td><td>3.1</td><td>775k</td></tr>
          <tr><td>SELECT ... JOIN orders ...</td><td>40k</td><td>12.4</td><td>496k</td></tr>
        </tbody>
      </table>
      <p class="mini">Porównuj <code>avg_ms</code> (pojedynczy koszt) i <code>calls</code> (częstotliwość) – priorytet mają zapytania „częste i kosztowne”.</p>
    </details>

    <!-- ===================== PARAMETRY KONFIGURACYJNE ===================== -->
    <h2>Parametry konfiguracyjne</h2>
    <p>Ostrożnie: modyfikuj, testując najpierw na stagingu. Poniżej najczęstsze „gałki”.</p>

    <h3>MySQL</h3>
    <ul>
      <li><code>innodb_buffer_pool_size</code> – bufor danych InnoDB (na serwerze dedykowanym MySQL zwykle większość RAM).</li>
      <li><code>innodb_log_file_size</code> – rozmiar dziennika redo (wpływa na I/O i checkpointy).</li>
      <li><code>innodb_flush_log_at_trx_commit</code> – trwałość vs. wydajność (1 = pełna trwałość, 2/0 = szybciej, mniej trwałe).</li>
    </ul>
    <pre><code class="language-ini">[mysqld]
innodb_buffer_pool_size = 4G
innodb_log_file_size    = 512M
innodb_flush_log_at_trx_commit = 1</code></pre>

    <details>
      <summary class="table-title">Efekt (koncepcyjny)</summary>
      <table class="db-table">
        <thead><tr><th>parametr</th><th>niżej</th><th>wyżej</th><th>uwagi</th></tr></thead>
        <tbody>
          <tr><td>buffer_pool</td><td>więcej I/O z dysku</td><td>więcej z RAM</td><td>pilnuj, by nie „zjeść” całego RAM</td></tr>
          <tr><td>log_file_size</td><td>częstsze checkpointy</td><td>rzadsze checkpointy</td><td>większe pliki redo = dłuższy start</td></tr>
          <tr><td>flush_log_at_trx_commit</td><td>bezpieczniej</td><td>szybciej</td><td>2/0 = możliwa strata danych przy awarii</td></tr>
        </tbody>
      </table>
    </details>

    <h3>PostgreSQL</h3>
    <ul>
      <li><code>shared_buffers</code> – pamięć bufora danych Postgresa.</li>
      <li><code>work_mem</code> – RAM na sorty/hash join <em>per operacja</em> i <em>per zapytanie</em>.</li>
      <li><code>maintenance_work_mem</code> – RAM dla VACUUM/CREATE INDEX.</li>
      <li><code>effective_cache_size</code> – szacowana pamięć podręczna systemu (pomaga optymalizatorowi).</li>
    </ul>
    <pre><code class="language-ini">shared_buffers         = 2GB
work_mem               = 64MB
maintenance_work_mem   = 1GB
effective_cache_size   = 6GB</code></pre>

    <details>
      <summary class="table-title">Efekt (koncepcyjny)</summary>
      <table class="db-table">
        <thead><tr><th>parametr</th><th>zbyt mało</th><th>zbyt dużo</th><th>uwagi</th></tr></thead>
        <tbody>
          <tr><td>shared_buffers</td><td>więcej I/O</td><td>mniej RAM dla OS cache</td><td>dobierz do profilu obciążenia</td></tr>
          <tr><td>work_mem</td><td>sorty na dysku</td><td>ryzyko OOM przy wielu zapytaniach</td><td>to limit „na operację”</td></tr>
          <tr><td>effective_cache_size</td><td>zbyt ostrożne plany</td><td>—</td><td>to tylko wskazówka dla planisty</td></tr>
        </tbody>
      </table>
    </details>

    <!-- ===================== ANALIZA LOGÓW ===================== -->
    <h2>Analiza logów</h2>

    <h3>Slow query log (MySQL)</h3>
    <pre><code class="language-ini">[mysqld]
slow_query_log      = ON
slow_query_log_file = /var/log/mysql/slow.log
long_query_time     = 1         # sekundy</code></pre>

    <p>Potem przeglądaj plik lub użyj narzędzi (np. <code>pt-query-digest</code>).</p>

    <details>
      <summary class="table-title">Co zobaczysz w slow log?</summary>
      <table class="db-table">
        <thead><tr><th>pole</th><th>przykład</th><th>znaczenie</th></tr></thead>
        <tbody>
          <tr><td>Query_time</td><td>2.131</td><td>czas wykonania</td></tr>
          <tr><td>Rows_examined</td><td>150000</td><td>ile wierszy „skanowano”</td></tr>
          <tr><td>Rows_sent</td><td>10</td><td>ile wierszy zwrócono</td></tr>
          <tr><td>Full_scan</td><td>Yes/No</td><td>czy był pełny skan tabeli</td></tr>
        </tbody>
      </table>
      <p class="mini">Duże <code>Rows_examined</code> + małe <code>Rows_sent</code> ⇒ kandydat na indeks lub lepszy warunek WHERE.</p>
    </details>

    <h3>log_min_duration_statement (PostgreSQL)</h3>
    <pre><code class="language-ini"># postgresql.conf
log_min_duration_statement = 1000    # ms – loguj zapytania > 1s
log_statement = 'ddl'                # loguj zmiany schematu</code></pre>

    <details>
      <summary class="table-title">Jak czytać wpisy z logów?</summary>
      <table class="db-table">
        <thead><tr><th>fragment logu</th><th>co mówi</th></tr></thead>
        <tbody>
          <tr><td>duration: 2150.123 ms statement: SELECT ...</td><td>czas wykonania konkretnego zapytania</td></tr>
          <tr><td>ERROR: deadlock detected</td><td>zakleszczenie – przeanalizuj transakcje i blokady</td></tr>
        </tbody>
      </table>
      <p class="mini">Łącz logi z metrykami (CPU, I/O, RAM) – całościowy obraz problemu.</p>
    </details>

    <!-- ===================== SZYBKA DIAGNOZA I TUNING ===================== -->
    <h2>Szybka ścieżka: diagnoza → poprawa</h2>

    <h3>1) Zidentyfikuj winowajców</h3>
    <ul>
      <li>MySQL: Performance Schema / slow log.</li>
      <li>PostgreSQL: pg_stat_statements / log_min_duration_statement.</li>
    </ul>

    <h3>2) Zrozum plan wykonania</h3>
    <pre><code class="language-sql">-- Postgres
EXPLAIN ANALYZE
SELECT ...;

-- MySQL
EXPLAIN FORMAT=JSON
SELECT ...;</code></pre>

    <details>
      <summary class="table-title">Na co patrzeć w planie?</summary>
      <table class="db-table">
        <thead><tr><th>element</th><th>co oznacza</th><th>reakcja</th></tr></thead>
        <tbody>
          <tr><td>Seq Scan / Full Table Scan</td><td>pełny skan tabeli</td><td>dodaj indeks do warunku WHERE / JOIN</td></tr>
          <tr><td>Rows / Actual Rows</td><td>ile wierszy szacuje/realnie przetwarza</td><td>zaktualizuj statystyki; rozważ lepsze selektory</td></tr>
          <tr><td>Sort / HashAggregate na dysku</td><td>operacje rozlane na dysk</td><td>zwiększ work_mem / przepisać zapytanie</td></tr>
        </tbody>
      </table>
    </details>

    <h3>3) Wprowadź poprawki</h3>
    <ul>
      <li>Dodaj/zmień indeksy pod <code>WHERE</code>, <code>JOIN</code>, <code>ORDER BY</code>.</li>
      <li>Unikaj <code>SELECT *</code> – wybieraj konkretne kolumny.</li>
      <li>Uprość filtrowanie – przenieś wyliczenia na kolumny generowane/denormalizację (gdy uzasadnione).</li>
      <li>Skaluj parametry pamięci, ale z głową (OOM boli bardziej niż powolny sort).</li>
    </ul>

    <h3>4) Zweryfikuj efekt</h3>
    <ul>
      <li>Porównaj <code>avg_ms</code>, <code>total_ms</code>, <code>Rows_examined</code> przed/po.</li>
      <li>Sprawdź plan: czy używany jest <em>Index Scan</em> zamiast skanu sekwencyjnego?</li>
    </ul>

    <details>
      <summary class="table-title">Przykład „przed/po” (koncepcyjny)</summary>
      <div class="grid-two">
        <table class="db-table">
          <caption class="mini">Przed indeksem</caption>
          <thead><tr><th>zapytanie</th><th>avg_ms</th><th>Rows_examined</th></tr></thead>
          <tbody>
            <tr><td>SELECT ... WHERE email='x@x'</td><td>120</td><td>150k</td></tr>
          </tbody>
        </table>
        <table class="db-table">
          <caption class="mini">Po indeksie na (email)</caption>
          <thead><tr><th>zapytanie</th><th>avg_ms</th><th>Rows_examined</th></tr></thead>
          <tbody>
            <tr><td>SELECT ... WHERE email='x@x'</td><td><strong>2.1</strong></td><td><strong>1</strong></td></tr>
          </tbody>
        </table>
      </div>
      <p class="mini">Indeks „zawęża” wyszukiwanie – zamiast skanować wszystko, trafiasz w konkretny zakres.</p>
    </details>

    <h2>Wskazówki</h2>
    <ul>
      <li>Monitoruj ciągle – po zmianach sprawdzaj, czy nie poprawiłeś jednego kosztem innego.</li>
      <li>Używaj narzędzi wizualizacyjnych (np. PMM/Percona, pgAdmin, Grafana+Exporter).</li>
      <li>Testuj na stagingu przed produkcją.</li>
      <li>Łącz metryki zapytań z metrykami systemu (CPU, RAM, I/O, sieć).</li>
      <li>Regularnie sprzątaj i rotuj logi (miejsce na dysku!).</li>
    </ul>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-ini.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-sql.min.js"></script>

  <!-- Styl TYLKO do wizualizacji; nie rusza Twojego styles.css -->
  <style>
    .db-table{width:100%;border-collapse:collapse;margin:.5rem 0}
    .db-table th,.db-table td{border:1px solid #1f2937;padding:.5rem .65rem;text-align:left;vertical-align:top}
    .db-table th{background:#0e1729;color:#dbe2ea}
    .null{color:#9ca3af;font-style:italic}
    details{margin:.75rem 0;border:1px solid #1f2937;border-radius:.5rem;padding:.25rem .5rem;background:#0e1729}
    details[open]{background:#111827}
    summary{cursor:pointer;list-style:none}
    summary::-webkit-details-marker{display:none}
    .table-title{font-weight:600;margin:.25rem 0}
    .mini{color:#a7b0be;font-size:.95rem;margin:.25rem 0 .5rem}
    .note{border-left:4px solid #10b981;padding:.75rem 1rem;background:#0e1729;border-radius:.5rem;margin:1rem 0;color:#cfe3d8}
    .grid-two{display:grid;grid-template-columns:1fr 1fr;gap:.75rem}
    @media (max-width: 900px){.grid-two{grid-template-columns:1fr}}
  </style>
</body>
</html>
