<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Agregacje w MongoDB</title>
    <link rel="stylesheet" href="../styles.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
</head>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Modal Example</title>
    <style>
        /* Styl dla modala */
        .modal {
            display: none; /* Ukryty domyślnie */
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 50%;
            max-height: 80%; /* Umożliwia przewijanie w pionie */
            overflow-y: auto; /* Dodaje przewijanie */
            background-color: #2e2e31;
            padding: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            z-index: 1000;
        }

        /* Tło pod modala */
        .modal-overlay {
            display: none; /* Ukryte domyślnie */
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 999;
        }

        /* Ukrywanie przewijania dla body, gdy modal jest aktywny */
        body.modal-active {
            overflow: hidden;
        }
    </style>
<body>
    <div class="container">
        <h1>Agregacje w MongoDB</h1>
        <p>Agregacje w MongoDB służą do przetwarzania danych i uzyskiwania podsumowań. Wykorzystują potok (ang. pipeline), który składa się z etapów (ang. stages) przekształcających dokumenty w celu uzyskania wyników.</p>

        <h2>Pipeline Agregacji</h2>
        <p>Pipeline agregacji to sekwencja etapów, które są wykonywane na danych w celu ich przekształcenia i analizy. Oto przykład użycia potoku agregacji:</p>
        <pre><code class="language-javascript">
// Przykład pipeline agregacji
db.kolekcja.aggregate([
    { $match: { status: \"aktywny\" } },
    { $group: { _id: \"$kategoria\", liczba: { $sum: 1 } } },
    { $sort: { liczba: -1 } }
]);
        </code></pre>

        <p>W tym przykładzie:</p>
        <ul>
            <li><code>$match</code> – filtruje dokumenty o statusie „aktywny”.</li>
            <li><code>$group</code> – grupuje dokumenty według kategorii i liczy liczbę wystąpień.</li>
            <li><code>$sort</code> – sortuje wyniki malejąco według liczby.</li>
        </ul>

        <h2>Operatory Agregacyjne</h2>
        <p>Podczas tworzenia pipeline agregacji można używać różnych operatorów, takich jak:</p>
        <ul>
            <li><code>$sum</code> – sumuje wartości.</li>
            <li><code>$avg</code> – oblicza średnią.</li>
            <li><code>$min</code>, <code>$max</code> – zwraca minimalną lub maksymalną wartość.</li>
            <li><code>$push</code> – tworzy tablicę z wartościami.</li>
            <li><code>$first</code>, <code>$last</code> – zwraca pierwszą lub ostatnią wartość w grupie.</li>
        </ul>

        <h2>Map-Reduce</h2>
        <p>Map-Reduce to alternatywna metoda agregacji danych, która jest bardziej elastyczna, ale wolniejsza w porównaniu do pipeline agregacji. Używa dwóch funkcji: <code>map</code> i <code>reduce</code>.</p>
        <pre><code class="language-javascript">
// Przykład użycia map-reduce
db.kolekcja.mapReduce(
    function() {
        emit(this.kategoria, 1);
    },
    function(klucz, wartosci) {
        return Array.sum(wartosci);
    },
    {
        out: \"wynikiAgregacji\"
    }
);
        </code></pre>

    <div class="section">
        <h2>Czym jest mapReduce?</h2>
        <p><strong>mapReduce</strong> to metoda w MongoDB używana do przetwarzania dużej ilości danych i ich agregacji. Jest podzielona na dwa etapy:</p>
        <ul>
            <li><strong>Map:</strong> Odpowiada za przekształcenie dokumentów w pary klucz-wartość.</li>
            <li><strong>Reduce:</strong> Łączy wartości o tych samych kluczach.</li>
        </ul>
    </div>

    <div class="section">
        <h2>Funkcja Map</h2>
        <p>Funkcja mapująca (map) jest wykonywana dla każdego dokumentu w kolekcji:</p>
        <pre><code class="language-javascript">
function() {
    emit(this.kategoria, 1);
}
        </code></pre>
        <p>Opis:</p>
        <ul>
            <li><code>this.kategoria</code>: Odnosi się do pola <code>kategoria</code> w bieżącym dokumencie.</li>
            <li><code>emit(klucz, wartość)</code>: Tworzy pary klucz-wartość, np. "Elektronika" -> 1.</li>
        </ul>
        <p>Przykładowe dane wejściowe:</p>
        <pre><code class="language-javascript">
{ "kategoria": "Elektronika" }
{ "kategoria": "Książki" }
{ "kategoria": "Elektronika" }
        </code></pre>
        <p>Po mapowaniu:</p>
        <pre><code class="language-javascript">
"Elektronika" -> 1
"Książki" -> 1
"Elektronika" -> 1
        </code></pre>
    </div>

    <div class="section">
        <h2>Funkcja Reduce</h2>
        <p>Funkcja redukująca (reduce) grupuje wartości o tych samych kluczach:</p>
        <pre><code class="language-javascript">
function(klucz, wartosci) {
    return Array.sum(wartosci);
}
        </code></pre>
        <p>Opis:</p>
        <ul>
            <li><code>klucz</code>: Klucz, czyli kategoria (np. "Elektronika").</li>
            <li><code>wartosci</code>: Tablica wartości emitowanych w map (np. [1, 1]).</li>
            <li><code>Array.sum(wartosci)</code>: Dodaje wartości w tablicy.</li>
        </ul>
        <p>Przykład działania:</p>
        <pre><code class="language-javascript">
"Elektronika": [1, 1] -> 2
"Książki": [1] -> 1
        </code></pre>
    </div>

    <div class="section">
        <h2>Wynik działania</h2>
        <p>Wynik funkcji mapReduce jest zapisywany w nowej kolekcji:</p>
        <pre><code class="language-javascript">
{
    out: "wynikiAgregacji"
}
        </code></pre>
        <p>Przykładowe dane wejściowe:</p>
        <pre><code class="language-javascript">
db.kolekcja.insertMany([
    { "kategoria": "Elektronika" },
    { "kategoria": "Książki" },
    { "kategoria": "Elektronika" },
    { "kategoria": "Odzież" },
    { "kategoria": "Odzież" },
    { "kategoria": "Odzież" }
]);
        </code></pre>
        <p>Wynik w kolekcji <code>wynikiAgregacji</code>:</p>
        <pre><code class="language-javascript">
{
    "_id": "Elektronika",
    "value": 2
},
{
    "_id": "Książki",
    "value": 1
},
{
    "_id": "Odzież",
    "value": 3
}
        </code></pre>
    </div>

    <div class="section">
        <h2>Zalety i wady</h2>
        <ul>
            <li><strong>Zalety:</strong> Pozwala przetwarzać duże zbiory danych, umożliwia zaawansowaną agregację.</li>
            <li><strong>Wady:</strong> Może być wolniejszy od <code>aggregation framework</code> w MongoDB.</li>
        </ul>
    </div>

        <h2>Podsumowanie</h2>
        <ul>
            <li>Pipeline agregacji pozwala na wydajne przetwarzanie i analizę danych.</li>
            <li>Operatory agregacyjne umożliwiają wykonywanie różnych obliczeń na danych.</li>
            <li>Map-Reduce jest elastyczne, ale zwykle mniej wydajne niż pipeline agregacji.</li>
        </ul>
        <button id="openModalBtn">Pojęcia</button>
    </div>
    <!-- Tło pod modala -->
    <div id="modalOverlay" class="modal-overlay"></div>

    <!-- Modal -->
    <div id="modal" class="modal">

        <h2>Agregacje</h2>
        <p>Proces przetwarzania danych i generowania podsumowań w celu uzyskania wartościowych informacji. Agregacje są szczególnie przydatne do analizowania dużych zestawów danych.</p>

        <h2>Pipeline (Potok)</h2>
        <p>Sekwencja etapów, które są wykonywane jeden po drugim na dokumentach w bazie danych. Każdy etap w potoku przekształca dokumenty i przekazuje je do kolejnego etapu.</p>

        <h2>Stage (Etap)</h2>
        <p>Pojedynczy krok w pipeline, który wykonuje określoną operację, np. filtrowanie danych, grupowanie czy sortowanie. Przykładami etapów są <code>$match</code>, <code>$group</code>, <code>$sort</code>.</p>

        <button id="closeModalBtn">Zamknij</button>
    </div>
        

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-javascript.min.js"></script>
    <script>
        // Pobieranie elementów
        const openModalBtn = document.getElementById('openModalBtn');
        const closeModalBtn = document.getElementById('closeModalBtn');
        const modal = document.getElementById('modal');
        const modalOverlay = document.getElementById('modalOverlay');

        // Funkcja otwierająca modal
        openModalBtn.addEventListener('click', () => {
            modal.style.display = 'block';
            modalOverlay.style.display = 'block';
            document.body.classList.add('modal-active'); // Zablokowanie przewijania body
        });

        // Funkcja zamykająca modal
        closeModalBtn.addEventListener('click', () => {
            modal.style.display = 'none';
            modalOverlay.style.display = 'none';
            document.body.classList.remove('modal-active'); // Odblokowanie przewijania body
        });

        // Zamknięcie modala po kliknięciu w overlay
        modalOverlay.addEventListener('click', () => {
            modal.style.display = 'none';
            modalOverlay.style.display = 'none';
            document.body.classList.remove('modal-active'); // Odblokowanie przewijania body
        });
    </script>
</body>
</html>
