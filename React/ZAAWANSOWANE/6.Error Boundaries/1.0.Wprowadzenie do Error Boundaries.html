<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wprowadzenie do Error Boundaries w React</title>
    <link rel="stylesheet" href="/React/styles.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
</head>
<body>
    <div class="container">
        <h1>Wprowadzenie do Error Boundaries w React</h1>

        <p>Error Boundaries (granice błędów) to specjalne komponenty w React, które pozwalają na wychwytywanie błędów występujących w poddrzewie komponentów, a następnie odpowiednie ich obsłużenie bez przerywania działania całej aplikacji. Dzięki Error Boundaries możemy zapewnić, że błędy w jednej części aplikacji nie spowodują wyświetlenia pustego ekranu lub awarii całej aplikacji.</p>

        <h2>Kiedy używać Error Boundaries?</h2>
        <p>Error Boundaries powinny być używane wszędzie tam, gdzie istnieje ryzyko, że komponent może rzucić wyjątek, który może spowodować awarię interfejsu użytkownika. Przykłady takich miejsc to:</p>
        <ul>
            <li>Komponenty odpowiedzialne za wyświetlanie zewnętrznych danych (np. z API), gdzie mogą wystąpić błędy sieciowe.</li>
            <li>Złożone komponenty, które mają skomplikowaną logikę, np. komponenty formularzy.</li>
            <li>Interaktywne elementy, takie jak galerie, które mogą generować błędy w wyniku interakcji użytkownika.</li>
        </ul>

        <h2>Jak działają Error Boundaries?</h2>
        <p>Error Boundaries to komponenty klasowe, które implementują dwie specjalne metody cyklu życia:</p>
        <ul>
            <li><code>static getDerivedStateFromError(error)</code> – Umożliwia aktualizację stanu komponentu w odpowiedzi na błąd.</li>
            <li><code>componentDidCatch(error, info)</code> – Umożliwia logowanie błędów oraz dodatkowych informacji o błędzie.</li>
        </ul>

        <h3>Prosty przykład Error Boundary</h3>
        <p>Oto przykład komponentu Error Boundary, który wyświetla zapasowy komunikat, gdy wystąpi błąd w jego podkomponentach:</p>

        <pre><code class="language-javascript">
// Komponent ErrorBoundary.js
import React from 'react';

class ErrorBoundary extends React.Component &#123;
  constructor(props) &#123;
    super(props);
    this.state = &#123; hasError: false &#125;;
  &#125;

  static getDerivedStateFromError(error) &#123;
    // Aktualizuje stan, aby wskazać, że wystąpił błąd
    return &#123; hasError: true &#125;;
  &#125;

  componentDidCatch(error, errorInfo) &#123;
    // Możesz tutaj zalogować błąd lub wysłać go do zewnętrznej usługi
    console.log('Błąd:', error, errorInfo);
  &#125;

  render() &#123;
    if (this.state.hasError) &#123;
      // Wyświetla zapasowy interfejs użytkownika
      return &lt;h1&gt;Coś poszło nie tak.&lt;/h1&gt;;
    &#125;

    return this.props.children;
  &#125;
&#125;

export default ErrorBoundary;
        </code></pre>

        <p>Ten komponent Error Boundary może być używany do "owijania" innych komponentów, aby wychwytywać błędy w ich poddrzewie:</p>

        <pre><code class="language-javascript">
import React from 'react';
import ErrorBoundary from './ErrorBoundary';
import MyComponent from './MyComponent';

function App() &#123;
  return (
    &lt;ErrorBoundary&gt;
      &lt;MyComponent /&gt;  {/* MyComponent zostanie owinięty przez ErrorBoundary */}
    &lt;/ErrorBoundary&gt;
  );
&#125;

export default App;
        </code></pre>

        <p>W tym przykładzie, jeśli komponent <code>MyComponent</code> rzuci wyjątek, zostanie on złapany przez <code>ErrorBoundary</code>, który wyświetli komunikat "Coś poszło nie tak" zamiast całkowicie przerwać działanie aplikacji.</p>

        <h2>Co Error Boundaries mogą obsługiwać?</h2>
        <p>Error Boundaries obsługują błędy rzucane w cyklu renderowania, w metodach cyklu życia komponentów i w konstruktorach podkomponentów. Jednak Error Boundaries <strong>nie</strong> mogą wychwytywać:</p>
        <ul>
            <li>Błędów asynchronicznych (np. w callbackach, <code>setTimeout</code>, czy <code>async/await</code>).</li>
            <li>Błędów, które występują w event handlerach (w tych przypadkach można ręcznie opakować event handler w try-catch).</li>
            <li>Błędów występujących w kodzie serwera (np. w przypadku renderowania po stronie serwera - SSR).</li>
        </ul>

        <h2>Testowanie Error Boundaries</h2>
        <p>Możesz przetestować Error Boundaries, symulując błąd w podkomponencie i sprawdzając, czy odpowiedni komunikat zapasowy jest renderowany:</p>

        <pre><code class="language-javascript">
// Test ErrorBoundary.test.js
import React from 'react';
import &#123; render, screen &#125; from '@testing-library/react';
import ErrorBoundary from './ErrorBoundary';

function ProblemComponent() &#123;
  throw new Error('Testowy błąd!');
&#125;

test('wyświetla komunikat o błędzie, gdy komponent rzuca wyjątek', () => &#123;
  render(
    &lt;ErrorBoundary&gt;
      &lt;ProblemComponent /&gt;
    &lt;/ErrorBoundary&gt;
  );
  expect(screen.getByText(/Coś poszło nie tak/i)).toBeInTheDocument();
&#125;);
        </code></pre>

        <p>Ten test symuluje sytuację, w której <code>ProblemComponent</code> rzuca wyjątek, a <code>ErrorBoundary</code> odpowiednio reaguje, wyświetlając komunikat o błędzie.</p>

        <h2>Przykład bardziej zaawansowanego Error Boundary</h2>
        <p>Możemy rozszerzyć nasz Error Boundary o możliwość resetowania stanu po kliknięciu przycisku "Spróbuj ponownie". Oto przykład:</p>

        <pre><code class="language-javascript">
import React from 'react';

class ErrorBoundary extends React.Component &#123;
  constructor(props) &#123;
    super(props);
    this.state = &#123; hasError: false &#125;;
  &#125;

  static getDerivedStateFromError(error) &#123;
    return &#123; hasError: true &#125;;
  &#125;

  componentDidCatch(error, errorInfo) &#123;
    console.log('Błąd:', error, errorInfo);
  &#125;

  resetError = () => &#123;
    this.setState(&#123; hasError: false &#125;);
  &#125;;

  render() &#123;
    if (this.state.hasError) &#123;
      return (
        &lt;div&gt;
          &lt;h1&gt;Coś poszło nie tak.&lt;/h1&gt;
          &lt;button onClick=&#123;this.resetError&#125;&gt;Spróbuj ponownie&lt;/button&gt;
        &lt;/div&gt;
      );
    &#125;

    return this.props.children;
  &#125;
&#125;

export default ErrorBoundary;
        </code></pre>

        <p>Ten rozszerzony komponent Error Boundary umożliwia użytkownikowi próbę ponownego załadowania komponentu po wystąpieniu błędu, co może być przydatne w sytuacjach, gdzie problem mógł być tymczasowy.</p>

        <h2>Kiedy Error Boundaries nie są potrzebne?</h2>
        <p>Nie wszystkie komponenty w aplikacji muszą być opakowane w Error Boundaries. W większości przypadków, Error Boundaries najlepiej stosować w komponentach wyższego poziomu, takich jak:</p>
        <ul>
            <li>Layouty całych stron.</li>
            <li>Kluczowe komponenty odpowiedzialne za nawigację lub wyświetlanie danych.</li>
            <li>Interaktywne komponenty, które mogą wywołać błędy na skutek działania użytkownika.</li>
        </ul>

        <h2>Podsumowanie</h2>
        <p>Error Boundaries w React są potężnym narzędziem do obsługi błędów, które pomagają zapobiegać całkowitej awarii aplikacji w przypadku wystąpienia problemów w podkomponentach. Dzięki Error Boundaries możesz wyświetlać zapasowy interfejs użytkownika, logować błędy, a nawet umożliwić użytkownikowi ponowienie próby, co znacząco poprawia doświadczenie użytkownika.</p>

        <ul>
            <li><strong>Error Boundaries:</strong> Specjalne komponenty do obsługi błędów w poddrzewie komponentów.</li>
            <li><strong>Metody cyklu życia:</strong> <code>getDerivedStateFromError</code> i <code>componentDidCatch</code> pozwalają obsługiwać błędy w komponentach.</li>
            <li><strong>Ograniczenia:</strong> Error Boundaries nie obsługują błędów asynchronicznych ani event handlerów.</li>
            <li><strong>Przykłady:</strong> Od prostego komponentu Error Boundary po bardziej zaawansowane rozwiązanie umożliwiające ponowną próbę po błędzie.</li>
        </ul>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-javascript.min.js"></script>
    <script src="https://unpkg.com/react@17/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>
</body>
</html>
