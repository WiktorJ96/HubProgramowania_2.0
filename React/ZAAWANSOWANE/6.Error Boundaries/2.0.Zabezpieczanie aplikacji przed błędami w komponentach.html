<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zabezpieczanie aplikacji przed błędami w komponentach w React</title>
    <link rel="stylesheet" href="/React/styles.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
</head>
<body>
    <div class="container">
        <h1>Zabezpieczanie aplikacji przed błędami w komponentach w React</h1>

        <p>W dużych aplikacjach React błędy w komponentach mogą prowadzić do niespodziewanych awarii aplikacji. Aby zapobiec temu problemowi i zwiększyć stabilność aplikacji, React wprowadził **komponenty typu Error Boundaries** (granice błędów). Pozwalają one na przechwytywanie i obsługę błędów, które występują podczas renderowania komponentów, cyklu życia lub w metodach zagnieżdżonych komponentów.</p>

        <h2>Co to są Error Boundaries?</h2>
        <p>**Error Boundaries** to specjalne komponenty React, które "wychwytują" błędy, uniemożliwiając ich propagację i awarie całej aplikacji. Zamiast tego, mogą wyświetlić komunikat o błędzie lub inny komponent zastępczy, gdy coś pójdzie nie tak.</p>

        <h2>Tworzenie komponentu Error Boundary</h2>
        <p>Aby utworzyć komponent typu Error Boundary, należy skorzystać z metody cyklu życia <code>componentDidCatch</code> lub użyć hooków takich jak <code>useEffect</code> w połączeniu z obsługą wyjątków. Poniżej znajduje się przykład komponentu Error Boundary.</p>

        <pre><code class="language-javascript">
        import React from 'react';

        class ErrorBoundary extends React.Component &#123;
          constructor(props) &#123;
            super(props);
            this.state = &#123; hasError: false &#125;;
          &#125;

          // Przechwytywanie błędów w komponentach podrzędnych
          static getDerivedStateFromError(error) &#123;
            return &#123; hasError: true &#125;;
          &#125;

          // Dodatkowe logowanie błędów
          componentDidCatch(error, errorInfo) &#123;
            console.error("Błąd przechwycony:", error, errorInfo);
          &#125;

          render() &#123;
            if (this.state.hasError) &#123;
              return &lt;h1&gt;Coś poszło nie tak.&lt;/h1&gt;;
            &#125;

            return this.props.children;
          &#125;
        &#125;

        export default ErrorBoundary;
        </code></pre>

        <p>W tym przykładzie komponent <code>ErrorBoundary</code> wykorzystuje metodę <code>getDerivedStateFromError</code>, aby ustawić stan <code>hasError</code> na <code>true</code>, gdy wystąpi błąd w jednym z komponentów podrzędnych. Następnie w metodzie <code>componentDidCatch</code> możemy zalogować błędy do zewnętrznego systemu lub konsoli. Gdy wystąpi błąd, użytkownik zobaczy komunikat zastępczy.</p>

        <h2>Używanie Error Boundaries w aplikacji</h2>
        <p>Komponenty typu Error Boundary powinny otaczać te części aplikacji, które mogą potencjalnie generować błędy. Najczęściej używa się ich wokół dużych sekcji aplikacji, takich jak całe widoki lub komponenty o skomplikowanej logice.</p>

        <h3>Przykład użycia Error Boundaries:</h3>
        <pre><code class="language-javascript">
        import React from 'react';
        import ErrorBoundary from './ErrorBoundary';
        import MyComponent from './MyComponent';

        function App() &#123;
          return (
            &lt;div&gt;
              &lt;ErrorBoundary&gt;
                &lt;MyComponent /&gt;  {/* Błędy w MyComponent będą przechwytywane */}
              &lt;/ErrorBoundary&gt;
            &lt;/div&gt;
          );
        &#125;

        export default App;
        </code></pre>

        <p>W tym przykładzie <code>MyComponent</code> jest otoczony przez komponent <code>ErrorBoundary</code>. Gdyby w <code>MyComponent</code> wystąpił błąd, aplikacja nie przestanie działać, a użytkownik zobaczy komunikat o błędzie.</p>

        <h2>Jakie błędy są przechwytywane przez Error Boundaries?</h2>
        <p>Komponenty Error Boundaries przechwytują błędy, które występują:</p>
        <ul>
          <li>Podczas renderowania.</li>
          <li>W metodach cyklu życia komponentu.</li>
          <li>W metodach zdarzeń komponentu (np. kliknięcia, przesłania formularza).</li>
        </ul>
        <p>Nie przechwytują jednak błędów, które występują w:</p>
        <ul>
          <li>Zdarzeniach asynchronicznych (np. <code>setTimeout</code> lub <code>requestAnimationFrame</code>).</li>
          <li>Serwerowym renderowaniu (Server-Side Rendering).</li>
          <li>Błędach w obsłudze promes (Promises) poza cyklem życia komponentu.</li>
        </ul>

        <h2>Obsługa błędów asynchronicznych</h2>
        <p>Aby obsługiwać błędy asynchroniczne, takie jak te występujące w zapytaniach HTTP lub obietnicach (Promises), musimy ręcznie obsługiwać wyjątki przy użyciu bloków <code>try-catch</code> lub innych metod zarządzania błędami.</p>

        <h3>Przykład obsługi błędów asynchronicznych:</h3>
        <pre><code class="language-javascript">
        import React, &#123; useState, useEffect &#125; from 'react';

        function DataFetcher() &#123;
          const [data, setData] = useState(null);
          const [error, setError] = useState(null);

          useEffect(() => &#123;
            const fetchData = async () => &#123;
              try &#123;
                const response = await fetch('https://jsonplaceholder.typicode.com/posts/1');
                const result = await response.json();
                setData(result);
              &#125; catch (error) &#123;
                setError('Wystąpił błąd podczas pobierania danych');
              &#125;
            &#125;;

            fetchData();
          &#125;, []);

          if (error) &#123;
            return &lt;p&gt;&#123;error&#125;&lt;/p&gt;;
          &#125;

          return &lt;div&gt;Dane: &#123;data && JSON.stringify(data)&#125;&lt;/div&gt;;
        &#125;

        export default DataFetcher;
        </code></pre>

        <p>W tym przykładzie obsługujemy błędy, które mogą wystąpić podczas asynchronicznego pobierania danych z API za pomocą bloku <code>try-catch</code>. Jeśli wystąpi błąd, komponent wyświetli odpowiednią wiadomość.</p>

        <h2>Granice błędów w aplikacjach produkcyjnych</h2>
        <p>W aplikacjach produkcyjnych warto dodać dodatkowe mechanizmy do Error Boundaries, takie jak:</p>
        <ul>
          <li>**Logowanie błędów** do zewnętrznych systemów (np. Sentry, LogRocket).</li>
          <li>**Automatyczne raportowanie** błędów użytkownikom lub administratorom.</li>
          <li>**Opcja ponownego renderowania** aplikacji po napotkaniu błędu (np. przyciski "Spróbuj ponownie").</li>
        </ul>

        <h3>Przykład z logowaniem błędów do zewnętrznego serwisu:</h3>
        <pre><code class="language-javascript">
        import React from 'react';
        import logErrorToService from './logErrorService';  // Funkcja do logowania błędów

        class ErrorBoundary extends React.Component &#123;
          constructor(props) &#123;
            super(props);
            this.state = &#123; hasError: false &#125;;
          &#125;

          static getDerivedStateFromError(error) &#123;
            return &#123; hasError: true &#125;;
          &#125;

          componentDidCatch(error, errorInfo) &#123;
            logErrorToService(error, errorInfo);  // Logowanie błędu do zewnętrznego serwisu
          &#125;

          render() &#123;
            if (this.state.hasError) &#123;
              return &lt;h1&gt;Coś poszło nie tak. Zgłoszono błąd.&lt;/h1&gt;;
            &#125;

            return this.props.children;
          &#125;
        &#125;

        export default ErrorBoundary;
        </code></pre>

        <p>W tym przykładzie używamy funkcji <code>logErrorToService</code>, która wysyła informacje o błędzie do zewnętrznego serwisu monitorującego, abyśmy mogli śledzić problemy występujące w aplikacji produkcyjnej.</p>

        <h2>Podsumowanie</h2>
        <p>Zabezpieczanie aplikacji przed błędami w komponentach React jest istotne dla stabilności i niezawodności aplikacji. Dzięki komponentom Error Boundaries możemy wychwytywać błędy w trakcie renderowania i cyklu życia komponentu, zamiast pozwalać na ich propagację i potencjalne awarie aplikacji. Ponadto, stosując dodatkowe techniki, takie jak logowanie błędów i obsługa błędów asynchronicznych, możemy stworzyć bardziej odporną aplikację.</p>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-javascript.min.js"></script>
</body>
</html>
