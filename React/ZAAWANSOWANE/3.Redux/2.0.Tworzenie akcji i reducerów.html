<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tworzenie akcji i reducerów w React</title>
    <link rel="stylesheet" href="/React/styles.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
</head>
<body>
    <div class="container">
        <h1>Tworzenie akcji i reducerów w React</h1>

        <p>W React, szczególnie w bardziej złożonych aplikacjach, zarządzanie stanem za pomocą <code>useState</code> może być niewystarczające lub skomplikowane. W takich sytuacjach idealnym rozwiązaniem jest zastosowanie hooka <code>useReducer</code>, który wykorzystuje **akcje** i **reducery** do zarządzania stanem w bardziej przewidywalny i strukturalny sposób.</p>

        <h2>Czym są akcje i reducery?</h2>
        <ul>
            <li>**Akcja** to obiekt, który zawiera informacje o tym, co powinno się stać. Zazwyczaj składa się z pola <code>type</code> (które opisuje typ akcji) oraz opcjonalnych danych (payload).</li>
            <li>**Reducer** to funkcja, która przyjmuje aktualny stan oraz akcję, a następnie zwraca nowy stan. Reducer nie mutuje stanu bezpośrednio – zamiast tego zawsze zwraca nowy obiekt stanu.</li>
        </ul>

        <h2>Tworzenie redukcji stanu przy użyciu <code>useReducer</code></h2>
        <p>W React, reducery są używane z hookiem <code>useReducer</code>, który jest alternatywą dla <code>useState</code> do zarządzania bardziej złożonym stanem. Przyjrzyjmy się przykładowi zarządzania stanem za pomocą akcji i redukcera.</p>

        <h3>Przykład: Licznik z <code>useReducer</code></h3>
        <pre><code class="language-javascript">
        import React, &#123; useReducer &#125; from 'react';

        // Definiowanie akcji
        const INCREMENT = 'increment';
        const DECREMENT = 'decrement';

        // Reducer - funkcja zarządzająca stanem
        function counterReducer(state, action) &#123;
          switch (action.type) &#123;
            case INCREMENT:
              return &#123; count: state.count + 1 &#125;;
            case DECREMENT:
              return &#123; count: state.count - 1 &#125;;
            default:
              throw new Error(`Nieznana akcja: &#123;action.type&#125;`);
          &#125;
        &#125;

        function Counter() &#123;
          // Użycie hooka useReducer
          const [state, dispatch] = useReducer(counterReducer, &#123; count: 0 &#125;);

          return (
            &lt;div&gt;
              &lt;p&gt;Licznik: &#123;state.count&#125;&lt;/p&gt;
              &lt;button onClick=&#123;() => dispatch(&#123; type: INCREMENT &#125;)&#125;&gt;Zwiększ&lt;/button&gt;
              &lt;button onClick=&#123;() => dispatch(&#123; type: DECREMENT &#125;)&#125;&gt;Zmniejsz&lt;/button&gt;
            &lt;/div&gt;
          );
        &#125;

        export default Counter;
        </code></pre>

        <p>W tym przykładzie definiujemy proste akcje: <code>INCREMENT</code> i <code>DECREMENT</code>. Reducer zarządza stanem, dodając lub odejmując wartość, w zależności od typu akcji. Hook <code>useReducer</code> zwraca obecny stan oraz funkcję <code>dispatch</code>, która służy do wywoływania akcji.</p>

        <h2>Struktura akcji</h2>
        <p>Akcje są zazwyczaj obiektami zawierającymi pole <code>type</code>, które opisuje typ wykonywanej akcji. Mogą również zawierać dodatkowe dane (tzw. **payload**), które są potrzebne do wykonania danej operacji.</p>

        <h3>Przykład akcji z danymi:</h3>
        <pre><code class="language-javascript">
        // Definiowanie akcji
        const SET_VALUE = 'set_value';

        // Reducer
        function valueReducer(state, action) &#123;
          switch (action.type) &#123;
            case SET_VALUE:
              return &#123; value: action.payload &#125;;  // Ustawienie nowej wartości
            default:
              throw new Error(`Nieznana akcja: &#123;action.type&#125;`);
          &#125;
        &#125;

        function ValueComponent() &#123;
          const [state, dispatch] = useReducer(valueReducer, &#123; value: 0 &#125;);
          const [inputValue, setInputValue] = useState('');

          return (
            &lt;div&gt;
              &lt;input 
                type="number" 
                value=&#123;inputValue&#125; 
                onChange=&#123;(e) => setInputValue(e.target.value)&#125; 
              /&gt;
              &lt;button onClick=&#123;() => dispatch(&#123; type: SET_VALUE, payload: parseInt(inputValue) &#125;)&#125;&gt;
                Ustaw wartość
              &lt;/button&gt;
              &lt;p&gt;Obecna wartość: &#123;state.value&#125;&lt;/p&gt;
            &lt;/div&gt;
          );
        &#125;

        export default ValueComponent;
        </code></pre>

        <p>W tym przykładzie mamy akcję <code>SET_VALUE</code>, która zawiera dodatkowe dane (payload) – w tym przypadku nową wartość wprowadzoną przez użytkownika. Reducer aktualizuje stan na podstawie tej wartości.</p>

        <h2>Zarządzanie złożonym stanem</h2>
        <p>Reducer jest idealnym rozwiązaniem do zarządzania złożonym stanem aplikacji, ponieważ pozwala w łatwy sposób dodawać nowe akcje i operacje bez wprowadzania niepotrzebnej złożoności.</p>

        <h3>Przykład: Formularz z kilkoma polami</h3>
        <pre><code class="language-javascript">
        import React, &#123; useReducer &#125; from 'react';

        // Definiowanie akcji
        const UPDATE_FIELD = 'update_field';

        // Reducer zarządzający stanem formularza
        function formReducer(state, action) &#123;
          switch (action.type) &#123;
            case UPDATE_FIELD:
              return &#123;
                ...state,
                [action.field]: action.value
              &#125;;
            default:
              throw new Error(`Nieznana akcja: &#123;action.type&#125;`);
          &#125;
        &#125;

        function FormComponent() &#123;
          const [state, dispatch] = useReducer(formReducer, &#123; name: '', email: '' &#125;);

          const handleChange = (e) => &#123;
            dispatch(&#123; type: UPDATE_FIELD, field: e.target.name, value: e.target.value &#125;);
          &#125;;

          return (
            &lt;form&gt;
              &lt;div&gt;
                &lt;label&gt;Imię:&lt;/label&gt;
                &lt;input 
                  type="text" 
                  name="name" 
                  value=&#123;state.name&#125; 
                  onChange=&#123;handleChange&#125; 
                /&gt;
              &lt;/div&gt;
              &lt;div&gt;
                &lt;label&gt;Email:&lt;/label&gt;
                &lt;input 
                  type="email" 
                  name="email" 
                  value=&#123;state.email&#125; 
                  onChange=&#123;handleChange&#125; 
                /&gt;
              &lt;/div&gt;
              &lt;p&gt;Wprowadzone imię: &#123;state.name&#125;&lt;/p&gt;
              &lt;p&gt;Wprowadzony email: &#123;state.email&#125;&lt;/p&gt;
            &lt;/form&gt;
          );
        &#125;

        export default FormComponent;
        </code></pre>

        <p>W tym przykładzie zarządzamy formularzem z kilkoma polami. Używamy jednej akcji <code>UPDATE_FIELD</code> do aktualizacji każdego pola na podstawie jego nazwy. Dzięki temu możemy w prosty sposób zarządzać stanem formularza bez potrzeby tworzenia oddzielnych funkcji dla każdego pola.</p>

        <h2>Akcje asynchroniczne z <code>useReducer</code></h2>
        <p>Chociaż <code>useReducer</code> sam w sobie nie obsługuje akcji asynchronicznych, możemy połączyć go z <code>useEffect</code> lub tworzyć asynchroniczne funkcje, które wykonują akcje w odpowiednim momencie.</p>

        <pre><code class="language-javascript">
        import React, &#123; useReducer, useEffect &#125; from 'react';

        const FETCH_SUCCESS = 'fetch_success';
        const FETCH_ERROR = 'fetch_error';

        function dataReducer(state, action) &#123;
          switch (action.type) &#123;
            case FETCH_SUCCESS:
              return &#123; ...state, data: action.payload, loading: false &#125;;
            case FETCH_ERROR:
              return &#123; ...state, error: 'Błąd podczas pobierania danych', loading: false &#125;;
            default:
              throw new Error(`Nieznana akcja: &#123;action.type&#125;`);
          &#125;
        &#125;

        function DataFetchingComponent() &#123;
          const [state, dispatch] = useReducer(dataReducer, &#123; data: null, loading: true, error: '' &#125;);

          useEffect(() => &#123;
            const fetchData = async () => &#123;
              try &#123;
                const response = await fetch('https://jsonplaceholder.typicode.com/posts/1');
                const data = await response.json();
                dispatch(&#123; type: FETCH_SUCCESS, payload: data &#125;);
              &#125; catch (error) &#123;
                dispatch(&#123; type: FETCH_ERROR &#125;);
              &#125;
            &#125;;

            fetchData();
          &#125;, []);

          if (state.loading) return &lt;p&gt;Ładowanie...&lt;/p&gt;;
          if (state.error) return &lt;p&gt;&#123;state.error&#125;&lt;/p&gt;;

          return &lt;div&gt;Dane: &#123;JSON.stringify(state.data)&#125;&lt;/div&gt;;
        &#125;

        export default DataFetchingComponent;
        </code></pre>

        <p>W tym przykładzie używamy <code>useReducer</code> do zarządzania stanem pobierania danych. Akcje <code>FETCH_SUCCESS</code> i <code>FETCH_ERROR</code> są wywoływane w zależności od wyniku zapytania HTTP. Dzięki temu mamy jasną strukturę zarządzania stanem nawet w przypadku operacji asynchronicznych.</p>

        <h2>Podsumowanie</h2>
        <p>Akcje i reducery w React pozwalają na efektywne zarządzanie bardziej złożonym stanem w aplikacji. Dzięki <code>useReducer</code> możemy przechowywać złożone struktury danych oraz łatwo zarządzać różnymi typami akcji. To podejście jest szczególnie przydatne w aplikacjach o skomplikowanej logice biznesowej, gdzie <code>useState</code> mogłoby być zbyt proste lub prowadzić do nieczytelnego kodu.</p>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-javascript.min.js"></script>
</body>
</html>
