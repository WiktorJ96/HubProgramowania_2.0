<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Używanie React.memo do optymalizacji wydajności</title>
    <link rel="stylesheet" href="/React/styles.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
</head>
<body>
    <div class="container">
        <h1>Używanie React.memo do optymalizacji wydajności</h1>

        <p><code>React.memo</code> to wyższy komponent (ang. <em>Higher Order Component</em>), który pozwala optymalizować wydajność komponentów funkcyjnych w React, zapobiegając niepotrzebnemu renderowaniu komponentów, jeśli ich propsy nie uległy zmianie. Działa to w sposób podobny do <code>shouldComponentUpdate</code> w komponentach klasowych.</p>

        <h2>Kiedy używać React.memo?</h2>
        <p><code>React.memo</code> jest szczególnie przydatny, gdy komponenty otrzymują te same propsy wielokrotnie, ale nie muszą być ponownie renderowane. Można go używać w komponentach, które mają skomplikowaną logikę renderowania lub są kosztowne w renderowaniu.</p>

        <h2>Jak działa React.memo?</h2>
        <p>React.memo sprawdza, czy propsy przekazane do komponentu zmieniły się od ostatniego renderowania. Jeśli nie, komponent nie zostanie ponownie wyrenderowany, co może poprawić wydajność aplikacji. Zobaczmy, jak używać React.memo na przykładzie:</p>

        <pre><code class="language-javascript">
import React from 'react';

// Komponent Child opakowany w React.memo
const Child = React.memo(function ChildComponent(&#123; name &#125;) &#123;
  console.log('Renderowanie komponentu Child');
  return &lt;p&gt;Witaj, &#123;name&#125;&lt;/p&gt;;
&#125;);

function Parent() &#123;
  const [count, setCount] = React.useState(0);
  const [name, setName] = React.useState('Anna');

  return (
    &lt;div&gt;
      &lt;button onClick=&#123;() => setCount(count + 1)&#125;&gt;Zwiększ licznik&lt;/button&gt;
      &lt;button onClick=&#123;() => setName('Kamil')&#125;&gt;Zmień imię&lt;/button&gt;
      &lt;p&gt;Licznik: &#123;count&#125;&lt;/p&gt;
      &lt;Child name=&#123;name&#125; /&gt;
    &lt;/div&gt;
  );
&#125;

export default Parent;
        </code></pre>

        <p>W tym przykładzie mamy komponent <code>Parent</code>, który ma dwa stany: <code>count</code> i <code>name</code>. Komponent <code>Child</code> jest opakowany w <code>React.memo</code>, co oznacza, że zostanie ponownie wyrenderowany tylko wtedy, gdy wartość propsa <code>name</code> się zmieni. Jeśli klikniemy przycisk zmieniający licznik, komponent <code>Child</code> nie zostanie ponownie wyrenderowany, ponieważ props <code>name</code> nie uległ zmianie.</p>

        <h2>Jak działa React.memo pod maską?</h2>
        <p>Pod maską <code>React.memo</code> wykonuje płytkie porównanie propsów. Jeśli wartości propsów są takie same jak poprzednio (dla typów prymitywnych jak liczby, stringi itp.), komponent nie zostanie ponownie wyrenderowany. Jednak dla złożonych obiektów, jak tablice czy obiekty, konieczne może być bardziej zaawansowane porównanie.</p>

        <h2>React.memo z funkcją porównującą</h2>
        <p>Możesz dostarczyć funkcję porównującą do <code>React.memo</code>, aby dokładniej kontrolować, kiedy komponent powinien być ponownie renderowany. Oto przykład użycia funkcji porównującej:</p>

        <pre><code class="language-javascript">
import React from 'react';

// Komponent Child z funkcją porównującą propsy
const Child = React.memo(function ChildComponent(&#123; person &#125;) &#123;
  console.log('Renderowanie komponentu Child');
  return &lt;p&gt;Witaj, &#123;person.name&#125;&lt;/p&gt;;
&#125;, (prevProps, nextProps) => &#123;
  // Porównujemy tylko pole "name" obiektu person
  return prevProps.person.name === nextProps.person.name;
&#125;);

function Parent() &#123;
  const [count, setCount] = React.useState(0);
  const [person, setPerson] = React.useState(&#123; name: 'Anna' &#125;);

  return (
    &lt;div&gt;
      &lt;button onClick=&#123;() => setCount(count + 1)&#125;&gt;Zwiększ licznik&lt;/button&gt;
      &lt;button onClick=&#123;() => setPerson(&#123; name: 'Kamil' &#125;)&#125;&gt;Zmień imię&lt;/button&gt;
      &lt;p&gt;Licznik: &#123;count&#125;&lt;/p&gt;
      &lt;Child person=&#123;person&#125; /&gt;
    &lt;/div&gt;
  );
&#125;

export default Parent;
        </code></pre>

        <p>W tym przykładzie przekazujemy do <code>Child</code> obiekt <code>person</code> jako props. Zamiast domyślnego porównania (które w przypadku obiektów mogłoby być nieefektywne), używamy funkcji porównującej, która porównuje tylko pole <code>name</code>. Dzięki temu komponent <code>Child</code> zostanie ponownie wyrenderowany tylko wtedy, gdy zmieni się imię.</p>

        <h2>Kiedy nie używać React.memo?</h2>
        <p>Chociaż <code>React.memo</code> może poprawić wydajność, nie zawsze jest to konieczne. Nie używaj go w poniższych sytuacjach:</p>
        <ul>
            <li>Komponenty są bardzo lekkie i szybkie w renderowaniu – dodatkowa logika związana z porównywaniem propsów może być bardziej kosztowna niż sam render.</li>
            <li>Jeśli komponent nie otrzymuje żadnych propsów lub zmienia się bardzo często.</li>
            <li>Gdy logika renderowania i zmiana propsów są bardzo częste – memoizacja w tym przypadku nie przyniesie znaczących korzyści.</li>
        </ul>

        <h2>Podsumowanie</h2>
        <p><code>React.memo</code> to świetne narzędzie do optymalizacji wydajności w aplikacjach React, szczególnie w przypadku komponentów funkcyjnych, które otrzymują te same propsy wielokrotnie. Poprzez zapobieganie niepotrzebnemu renderowaniu komponentów, <code>React.memo</code> może znacznie poprawić wydajność w bardziej złożonych aplikacjach.</p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-javascript.min.js"></script>
    <script src="https://unpkg.com/react@17/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>
</body>
</html>
