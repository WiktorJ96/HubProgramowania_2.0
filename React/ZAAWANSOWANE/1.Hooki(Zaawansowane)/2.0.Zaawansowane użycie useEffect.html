<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zaawansowane użycie useEffect w React</title>
    <link rel="stylesheet" href="/React/styles.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
</head>
<body>
    <div class="container">
        <h1>Zaawansowane użycie useEffect w React</h1>

        <p>Hook <code>useEffect</code> to jedno z najpotężniejszych narzędzi w React, które pozwala na wykonywanie efektów ubocznych, takich jak pobieranie danych, subskrypcje czy aktualizacje tytułu dokumentu. Chociaż <code>useEffect</code> jest często używany w podstawowy sposób (np. do pobierania danych przy montowaniu komponentu), posiada wiele bardziej zaawansowanych funkcji, które mogą pomóc w optymalizacji i zarządzaniu aplikacją.</p>

        <h2>Podstawowe użycie <code>useEffect</code></h2>
        <p>Najprostszym zastosowaniem <code>useEffect</code> jest wykonanie pewnego działania, gdy komponent zostanie zamontowany. W tym przypadku <code>useEffect</code> działa podobnie do metody <code>componentDidMount</code> z komponentów klasowych:</p>

        <pre><code class="language-javascript">
        import React, &#123; useEffect &#125; from 'react';

        function ExampleComponent() &#123;
          useEffect(() => &#123;
            console.log('Komponent został zamontowany.');
          &#125;, []);  // Pusty array oznacza, że efekt zostanie wykonany tylko raz, po zamontowaniu komponentu

          return &lt;div&gt;Hello, world!&lt;/div&gt;;
        &#125;

        export default ExampleComponent;
        </code></pre>

        <p>W tym przypadku efekt wykonuje się tylko raz, po zamontowaniu komponentu, dzięki pustemu arrayowi jako drugiemu argumentowi. To podstawowe zastosowanie <code>useEffect</code>, które jest bardzo popularne.</p>

        <h2>Efekty zależne od danych</h2>
        <p>Jednym z bardziej zaawansowanych sposobów użycia <code>useEffect</code> jest przekazanie listy zależności, które kontrolują, kiedy efekt zostanie ponownie wykonany. Oto przykład, w którym efekt jest uruchamiany, gdy zmienia się wartość <code>count</code>:</p>

        <pre><code class="language-javascript">
        import React, &#123; useState, useEffect &#125; from 'react';

        function Counter() &#123;
          const [count, setCount] = useState(0);

          useEffect(() => &#123;
            console.log(`Licznik został zaktualizowany: &#123;count&#125;`);
          &#125;, [count]);  // Efekt wykonuje się za każdym razem, gdy zmienia się "count"

          return (
            &lt;div&gt;
              &lt;p&gt;Licznik: &#123;count&#125;&lt;/p&gt;
              &lt;button onClick=&#123;() => setCount(count + 1)&#125;&gt;Zwiększ licznik&lt;/button&gt;
            &lt;/div&gt;
          );
        &#125;

        export default Counter;
        </code></pre>

        <p>W tym przykładzie efekt będzie wywoływany za każdym razem, gdy wartość <code>count</code> ulegnie zmianie. To pozwala na reagowanie na zmiany w danych w sposób kontrolowany.</p>

        <h2>Czyszczenie efektów</h2>
        <p>Hook <code>useEffect</code> zwraca również funkcję, która może być używana do czyszczenia zasobów lub zatrzymywania pewnych procesów. Jest to przydatne w przypadku, gdy komponent zostaje usunięty z DOM, a my musimy zatrzymać na przykład timer lub anulować zapytania sieciowe.</p>

        <pre><code class="language-javascript">
        import React, &#123; useState, useEffect &#125; from 'react';

        function Timer() &#123;
          const [seconds, setSeconds] = useState(0);

          useEffect(() => &#123;
            const interval = setInterval(() => &#123;
              setSeconds(prevSeconds => prevSeconds + 1);
            &#125;, 1000);

            return () => &#123;
              clearInterval(interval);  // Czyszczenie timera po odmontowaniu komponentu
              console.log('Timer został wyczyszczony.');
            &#125;;
          &#125;, []);  // Efekt uruchamiany tylko raz, po zamontowaniu komponentu

          return &lt;p&gt;Sekundy: &#123;seconds&#125;&lt;/p&gt;;
        &#125;

        export default Timer;
        </code></pre>

        <p>W tym przykładzie efekt ustawia timer, który zlicza sekundy. Gdy komponent zostanie usunięty z DOM, efekt zwraca funkcję czyszczącą, która zatrzymuje timer za pomocą <code>clearInterval</code>.</p>

        <h2>Unikanie niepotrzebnych efektów</h2>
        <p>Jednym z typowych błędów podczas używania <code>useEffect</code> jest uruchamianie efektu przy każdej zmianie stanu, nawet jeśli nie jest to potrzebne. Przekazując listę zależności, możemy określić, kiedy efekt powinien się wykonać, co pozwala na optymalizację aplikacji i unikanie zbędnych aktualizacji.</p>

        <pre><code class="language-javascript">
        import React, &#123; useState, useEffect &#125; from 'react';

        function OptimizedComponent() &#123;
          const [count, setCount] = useState(0);
          const [name, setName] = useState('');

          useEffect(() => &#123;
            console.log('Zmieniono count:', count);
          &#125;, [count]);  // Efekt wykona się tylko, gdy zmieni się "count"

          return (
            &lt;div&gt;
              &lt;p&gt;Licznik: &#123;count&#125;&lt;/p&gt;
              &lt;button onClick=&#123;() => setCount(count + 1)&#125;&gt;Zwiększ licznik&lt;/button&gt;
              &lt;input
                type="text"
                value=&#123;name&#125;
                onChange=&#123;(e) => setName(e.target.value)&#125;
                placeholder="Podaj imię"
              /&gt;
            &lt;/div&gt;
          );
        &#125;

        export default OptimizedComponent;
        </code></pre>

        <p>W tym przykładzie efekt zależy tylko od zmiany wartości <code>count</code>, więc będzie się wykonywał tylko wtedy, gdy <code>count</code> zostanie zaktualizowane. Zmiana wartości <code>name</code> nie spowoduje wykonania efektu, co optymalizuje działanie aplikacji.</p>

        <h2>Synchronizacja danych asynchronicznych</h2>
        <p><code>useEffect</code> doskonale nadaje się do synchronizacji danych asynchronicznych, takich jak zapytania HTTP do API. Ważne jest, aby odpowiednio obsługiwać asynchroniczne funkcje wewnątrz efektów.</p>

        <pre><code class="language-javascript">
        import React, &#123; useState, useEffect &#125; from 'react';

        function DataFetchingComponent() &#123;
          const [data, setData] = useState(null);
          const [loading, setLoading] = useState(true);

          useEffect(() => &#123;
            const fetchData = async () => &#123;
              try &#123;
                const response = await fetch('https://jsonplaceholder.typicode.com/posts/1');
                const result = await response.json();
                setData(result);
              &#125; catch (error) &#123;
                console.error('Błąd podczas pobierania danych:', error);
              &#125; finally &#123;
                setLoading(false);
              &#125;
            &#125;;

            fetchData();
          &#125;, []);  // Efekt wykonuje się tylko raz, po zamontowaniu komponentu

          if (loading) return &lt;p&gt;Ładowanie...&lt;/p&gt;;
          return &lt;div&gt;Dane: &#123;JSON.stringify(data)&#125;&lt;/div&gt;;
        &#125;

        export default DataFetchingComponent;
        </code></pre>

        <p>W tym przykładzie używamy <code>useEffect</code> do pobrania danych z API po zamontowaniu komponentu. Warto zauważyć, że asynchroniczną funkcję <code>fetchData</code> wywołujemy wewnątrz efektu, ale nie możemy bezpośrednio uczynić <code>useEffect</code> asynchronicznym (nie powinno się używać <code>async</code> w definicji <code>useEffect</code>).</p>

        <h2>Efekty z wieloma zależnościami</h2>
        <p>Możemy używać <code>useEffect</code> z wieloma zależnościami, które spowodują ponowne wykonanie efektu, gdy którakolwiek z nich się zmieni.</p>

        <pre><code class="language-javascript">
        import React, &#123; useState, useEffect &#125; from 'react';

        function MultiDependencyEffect() &#123;
          const [count, setCount] = useState(0);
          const [name, setName] = useState('');

          useEffect(() => &#123;
            console.log('Count lub name zostały zmienione');
          &#125;, [count, name]);  // Efekt wykonuje się, gdy zmieni się "count" lub "name"

          return (
            &lt;div&gt;
              &lt;p&gt;Licznik: &#123;count&#125;&lt;/p&gt;
              &lt;button onClick=&#123;() => setCount(count + 1)&#125;&gt;Zwiększ licznik&lt;/button&gt;
              &lt;input
                type="text"
                value=&#123;name&#125;
                onChange=&#123;(e) => setName(e.target.value)&#125;
                placeholder="Podaj imię"
              /&gt;
            &lt;/div&gt;
          );
        &#125;

        export default MultiDependencyEffect;
        </code></pre>

        <p>W tym przykładzie efekt będzie wywoływany za każdym razem, gdy zmieni się wartość <code>count</code> lub <code>name</code>, dzięki czemu możemy zareagować na każdą zmianę tych zależności.</p>

        <h2>Podsumowanie</h2>
        <p>Hook <code>useEffect</code> to potężne narzędzie, które oferuje szerokie możliwości zarządzania efektami ubocznymi w komponentach funkcyjnych. Dzięki odpowiedniemu użyciu zależności, czyszczeniu efektów oraz synchronizacji danych asynchronicznych możemy stworzyć aplikacje, które są bardziej responsywne, zoptymalizowane i łatwe w utrzymaniu.</p>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-javascript.min.js"></script>
</body>
</html>
