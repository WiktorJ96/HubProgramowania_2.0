<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tworzenie własnych hooków w React</title>
    <link rel="stylesheet" href="/React/styles.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
</head>
<body>
    <div class="container">
        <h1>Tworzenie własnych hooków w React</h1>

        <p>W React możemy tworzyć własne hooki (ang. <em>custom hooks</em>), aby ponownie używać logiki w wielu komponentach. Własne hooki pozwalają na wyodrębnienie złożonej logiki z komponentów funkcyjnych, co czyni kod bardziej czytelnym i zorganizowanym. Hooki w React to funkcje, które mogą korzystać z innych hooków, takich jak <code>useState</code> i <code>useEffect</code>.</p>

        <h2>Podstawy tworzenia własnych hooków</h2>
        <p>Własny hook to po prostu funkcja w JavaScript, która zaczyna się od prefiksu <code>use</code> i może wywoływać inne hooki. Zobaczmy, jak stworzyć prosty hook do zarządzania licznikiem:</p>

        <pre><code class="language-javascript">
import React, &#123; useState &#125; from 'react';

// Tworzenie własnego hooka do licznika
function useCounter(initialValue = 0) &#123;
  const [count, setCount] = useState(initialValue);

  const increment = () => &#123; setCount(count + 1); &#125;;
  const decrement = () => &#123; setCount(count - 1); &#125;;

  return [count, increment, decrement];
&#125;

function CounterComponent() &#123;
  const [count, increment, decrement] = useCounter(10); // Użycie własnego hooka

  return (
    &lt;div&gt;
      &lt;p&gt;Licznik: &#123;count&#125;&lt;/p&gt;
      &lt;button onClick=&#123;increment&#125;&gt;Zwiększ&lt;/button&gt;
      &lt;button onClick=&#123;decrement&#125;&gt;Zmniejsz&lt;/button&gt;
    &lt;/div&gt;
  );
&#125;

ReactDOM.render(&lt;CounterComponent /&gt;, document.getElementById('root'));
        </code></pre>

        <p>W tym przykładzie stworzyliśmy hook <code>useCounter</code>, który zarządza licznikiem. Hook zwraca aktualną wartość licznika oraz funkcje do jego zwiększania i zmniejszania. Następnie używamy tego hooka w komponencie <code>CounterComponent</code>.</p>

        <h2>Własny hook z efektem ubocznym</h2>
        <p>Własne hooki mogą również korzystać z <code>useEffect</code> do obsługi efektów ubocznych. Zobaczmy przykład hooka, który reaguje na zmiany rozmiaru okna przeglądarki:</p>

        <pre><code class="language-javascript">
import React, &#123; useState, useEffect &#125; from 'react';

// Tworzenie własnego hooka do śledzenia rozmiaru okna
function useWindowSize() &#123;
  const [size, setSize] = useState(&#123; width: window.innerWidth, height: window.innerHeight &#125;);

  useEffect(() => &#123;
    const handleResize = () => &#123;
      setSize(&#123; width: window.innerWidth, height: window.innerHeight &#125;);
    &#125;;

    window.addEventListener('resize', handleResize);

    // Czyszczenie po efekcie
    return () => &#123;
      window.removeEventListener('resize', handleResize);
    &#125;;
  &#125;, []);

  return size;
&#125;

function WindowSizeComponent() &#123;
  const size = useWindowSize(); // Użycie własnego hooka

  return (
    &lt;div&gt;
      &lt;p&gt;Szerokość: &#123;size.width&#125;&lt;/p&gt;
      &lt;p&gt;Wysokość: &#123;size.height&#125;&lt;/p&gt;
    &lt;/div&gt;
  );
&#125;

ReactDOM.render(&lt;WindowSizeComponent /&gt;, document.getElementById('root'));
        </code></pre>

        <p>W tym przykładzie hook <code>useWindowSize</code> śledzi rozmiar okna przeglądarki. Za każdym razem, gdy okno jest zmieniane, hook aktualizuje stan. Funkcja czyszcząca usuwa nasłuchiwacz zdarzeń po odmontowaniu komponentu, zapobiegając wyciekom pamięci.</p>

        <h2>Własny hook do pobierania danych</h2>
        <p>Własne hooki mogą być również używane do pobierania danych z API. Poniżej znajduje się przykład hooka <code>useFetch</code>, który pobiera dane z zewnętrznego API:</p>

        <pre><code class="language-javascript">
import React, &#123; useState, useEffect &#125; from 'react';

// Tworzenie własnego hooka do pobierania danych
function useFetch(url) &#123;
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => &#123;
    const fetchData = async () => &#123;
      const response = await fetch(url);
      const result = await response.json();
      setData(result);
      setLoading(false);
    &#125;;

    fetchData();
  &#125;, [url]);

  return [data, loading];
&#125;

function DataFetchingComponent() &#123;
  const [data, loading] = useFetch('https://jsonplaceholder.typicode.com/todos/1'); // Użycie własnego hooka

  return (
    &lt;div&gt;
      &lt;p&gt;&#123;loading ? 'Ładowanie...' : JSON.stringify(data)&#125;&lt;/p&gt;
    &lt;/div&gt;
  );
&#125;

ReactDOM.render(&lt;DataFetchingComponent /&gt;, document.getElementById('root'));
        </code></pre>

        <p>W tym przykładzie hook <code>useFetch</code> jest używany do pobierania danych z API. Hook zwraca pobrane dane oraz informację, czy dane są w trakcie ładowania. Dzięki temu hookowi możemy łatwo ponownie wykorzystać logikę pobierania danych w różnych komponentach.</p>

        <h2>Zasady tworzenia własnych hooków</h2>
        <p>Podczas tworzenia własnych hooków należy pamiętać o kilku zasadach:</p>
        <ul>
            <li><strong>Prefiks <code>use</code>:</strong> Nazwa własnego hooka zawsze musi zaczynać się od <code>use</code>, aby React mógł rozpoznać, że to hook.</li>
            <li><strong>Wywoływanie hooków:</strong> Własne hooki mogą wywoływać inne hooki, takie jak <code>useState</code> czy <code>useEffect</code>, ale muszą być używane w komponentach funkcyjnych lub innych hookach.</li>
            <li><strong>Wielokrotne użycie:</strong> Własne hooki pozwalają na wielokrotne użycie tej samej logiki w różnych miejscach aplikacji.</li>
        </ul>

        <h2>Podsumowanie</h2>
        <p>Tworzenie własnych hooków w React pozwala na uproszczenie i ponowne wykorzystanie logiki w wielu komponentach. Możemy używać ich do zarządzania stanem, efektami ubocznymi oraz do innych zadań, takich jak śledzenie rozmiaru okna czy pobieranie danych z API. Własne hooki sprawiają, że kod aplikacji staje się bardziej modularny, czytelny i łatwy w utrzymaniu.</p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-javascript.min.js"></script>
    <script src="https://unpkg.com/react@17/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>
</body>
</html>
