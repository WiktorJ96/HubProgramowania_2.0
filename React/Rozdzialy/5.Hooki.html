<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>React - Hooki</title>
    <link rel="stylesheet" href="../styles.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
</head>
<body>
    <div class="container">
        <h1>React - Hooki</h1>
        
        <p>Hooki to funkcje, ktÃ³re pozwalajÄ… â€zaczepiaÄ‡â€ (hook) mechanizmy Reacta (stan, efekty, itp.) w komponentach funkcyjnych. PoniÅ¼ej: <code>useState</code>, <code>useEffect</code> oraz wÅ‚asny hook.</p>

        <!-- ======================= useState ======================= -->
        <h2>useState</h2>
        <p><code>useState</code> zwraca parÄ™: <strong>stan</strong> i <strong>setter</strong>. Setter zmienia stan i powoduje ponowny render.</p>

        <pre><code class="language-javascript">
import React, { useState } from 'react';

function Counter() {
    const [count, setCount] = useState(0); // Inicjalizacja stanu z wartoÅ›ciÄ… poczÄ…tkowÄ… 0

    return (
        &lt;div&gt;
            &lt;p&gt;Licznik: {count}&lt;/p&gt;
            &lt;button onClick={() =&gt; setCount(count + 1)}&gt;ZwiÄ™ksz&lt;/button&gt;
        &lt;/div&gt;
    );
}
        </code></pre>

        <!-- Wizualizacja useState -->
        <details open>
          <summary class="viz-title">ğŸ“ˆ Wizualizacja dziaÅ‚ania: <strong>useState â€“ Counter</strong></summary>
          <div class="viz-wrap">
            <svg viewBox="0 0 1000 360" class="viz-svg">
              <defs>
                <marker id="arrow" markerWidth="12" markerHeight="12" refX="10" refY="6" orient="auto">
                  <path d="M0,0 L12,6 L0,12 Z" fill="#94a3b8"></path>
                </marker>
              </defs>

              <g class="lane" transform="translate(10,10)">
                <rect width="480" height="340" rx="12"></rect>
                <text x="16" y="28" class="lane-title">Klik â†’ setCount â†’ re-render</text>

                <g class="node" transform="translate(20,60)">
                  <rect width="440" height="54" rx="10"></rect>
                  <text x="12" y="22">onClick={() =&gt; setCount(count + 1)}</text>
                  <text x="12" y="40" class="muted">zdarzenie z przycisku</text>
                </g>

                <path d="M240,114 L240,148" class="arrow"/>
                <g class="pill" transform="translate(20,150)">
                  <rect width="440" height="54" rx="10"></rect>
                  <text x="12" y="22">setCount(count + 1)</text>
                  <text x="12" y="40" class="muted">aktualizacja stanu</text>
                </g>

                <path d="M240,204 L240,238" class="arrow"/>
                <g class="ok" transform="translate(20,240)">
                  <rect width="440" height="54" rx="10"></rect>
                  <text x="12" y="22">Re-render komponentu</text>
                  <text x="12" y="40" class="muted">nowy count widoczny w UI</text>
                </g>
              </g>

              <g class="lane" transform="translate(510,10)">
                <rect width="480" height="340" rx="12"></rect>
                <text x="16" y="28" class="lane-title">PowiÄ…zanie UI â†” stan</text>

                <g class="node" transform="translate(20,60)">
                  <rect width="440" height="54" rx="10"></rect>
                  <text x="12" y="22">&lt;p&gt;Licznik: { '{count}' }&lt;/p&gt;</text>
                  <text x="12" y="40" class="muted">czyta aktualny stan</text>
                </g>

                <g class="node" transform="translate(20,130)">
                  <rect width="440" height="54" rx="10"></rect>
                  <text x="12" y="22">&lt;button onClick=...&gt;</text>
                  <text x="12" y="40" class="muted">wywoÅ‚uje setCount</text>
                </g>

                <g class="ok" transform="translate(20,210)">
                  <rect width="440" height="54" rx="10"></rect>
                  <text x="12" y="32">UI aktualizuje tekst â€Licznik: Xâ€</text>
                </g>
              </g>
            </svg>

            <div class="grid-two">
              <table class="db-table">
                <caption class="mini">Stan poczÄ…tkowy</caption>
                <thead><tr><th>count</th></tr></thead>
                <tbody><tr><td>0</td></tr></tbody>
              </table>
              <table class="db-table">
                <caption class="mini">Po 2 klikniÄ™ciach</caption>
                <thead><tr><th>count</th></tr></thead>
                <tbody><tr><td>2</td></tr></tbody>
              </table>
            </div>
          </div>
        </details>

        <p>Tu setter (<code>setCount</code>) zmienia stan i wywoÅ‚uje ponowny render. UI â€czytaâ€ nowÄ… wartoÅ›Ä‡ i pokazuje jÄ….</p>

        <!-- ======================= useEffect ======================= -->
        <h2>useEffect</h2>
        <p><code>useEffect</code> uruchamia efekty uboczne po renderze (np. subskrypcje, timery). MoÅ¼e zwrÃ³ciÄ‡ funkcjÄ™ sprzÄ…tajÄ…cÄ….</p>

        <pre><code class="language-javascript">
import React, { useState, useEffect } from 'react';

function Timer() {
    const [time, setTime] = useState(new Date());

    useEffect(() => {
        const timerID = setInterval(() => setTime(new Date()), 1000);
        
        return () => clearInterval(timerID); // Czyszczenie timera przy odmontowywaniu
    }, []); // Pusta tablica = uruchom efekt tylko raz (po zamontowaniu)

    return &lt;h2&gt;Aktualna godzina: {time.toLocaleTimeString()}&lt;/h2&gt;;
}
        </code></pre>

        <!-- Wizualizacja useEffect -->
        <details>
          <summary class="viz-title">ğŸ“ˆ Wizualizacja dziaÅ‚ania: <strong>useEffect â€“ Timer</strong></summary>
          <div class="viz-wrap">
            <svg viewBox="0 0 1000 420" class="viz-svg">
              <defs>
                <marker id="arrow2" markerWidth="12" markerHeight="12" refX="10" refY="6" orient="auto">
                  <path d="M0,0 L12,6 L0,12 Z" fill="#94a3b8"></path>
                </marker>
              </defs>

              <g class="lane" transform="translate(10,10)">
                <rect width="480" height="400" rx="12"></rect>
                <text x="16" y="28" class="lane-title">MontaÅ¼ â†’ efekt â†’ sprzÄ…tanie</text>

                <g class="node" transform="translate(20,60)">
                  <rect width="440" height="54" rx="10"></rect>
                  <text x="12" y="22">Render + useEffect(() =&gt; {{...}}, [])</text>
                  <text x="12" y="40" class="muted">[] â†’ uruchom raz</text>
                </g>

                <path d="M240,114 L240,148" class="arrow2"/>
                <g class="ok" transform="translate(20,150)">
                  <rect width="440" height="54" rx="10"></rect>
                  <text x="12" y="22">setInterval(() =&gt; setTime(new Date()), 1000)</text>
                  <text x="12" y="40" class="muted">co sekundÄ™ aktualizuj stan</text>
                </g>

                <path d="M240,204 L240,238" class="arrow2"/>
                <g class="warn" transform="translate(20,240)">
                  <rect width="440" height="54" rx="10"></rect>
                  <text x="12" y="22">return () =&gt; clearInterval(timerID)</text>
                  <text x="12" y="40" class="muted">sprzÄ…tanie przy odmontowaniu</text>
                </g>
              </g>

              <g class="lane" transform="translate(510,10)">
                <rect width="480" height="400" rx="12"></rect>
                <text x="16" y="28" class="lane-title">Tick â†’ setTime â†’ re-render</text>

                <g class="node" transform="translate(20,60)">
                  <rect width="440" height="54" rx="10"></rect>
                  <text x="12" y="22">Tick (co 1000 ms)</text>
                  <text x="12" y="40" class="muted">callback z setInterval</text>
                </g>

                <g class="pill" transform="translate(20,130)">
                  <rect width="440" height="54" rx="10"></rect>
                  <text x="12" y="32">setTime(new Date())</text>
                </g>

                <g class="ok" transform="translate(20,200)">
                  <rect width="440" height="54" rx="10"></rect>
                  <text x="12" y="32">Re-render â†’ wyÅ›wietl nowy czas</text>
                </g>
              </g>
            </svg>

            <div class="grid-two">
              <table class="db-table">
                <caption class="mini">Stan po montaÅ¼u</caption>
                <thead><tr><th>time</th></tr></thead>
                <tbody><tr><td>np. 12:00:00</td></tr></tbody>
              </table>
              <table class="db-table">
                <caption class="mini">Po 2 sekundach</caption>
                <thead><tr><th>time</th></tr></thead>
                <tbody><tr><td>np. 12:00:02</td></tr></tbody>
              </table>
            </div>
          </div>
        </details>

        <p><em>Meritum:</em> efekt tworzy subskrypcjÄ™/timer, a funkcja zwracana sprzÄ…ta zasoby, gdy komponent znika.</p>

        <!-- ======================= WÅ‚asny hook ======================= -->
        <h2>Tworzenie WÅ‚asnych HookÃ³w</h2>
        <p>WÅ‚asny hook to funkcja zaczynajÄ…ca siÄ™ od <code>use</code>, ktÃ³ra moÅ¼e uÅ¼ywaÄ‡ innych hookÃ³w i kapsuÅ‚kuje wspÃ³lnÄ… logikÄ™.</p>

        <pre><code class="language-javascript">
// Importujemy niezbÄ™dne funkcje z React
import { useState, useEffect } from 'react';

// Definiujemy wÅ‚asny hook o nazwie useWindowWidth, ktÃ³ry Å›ledzi szerokoÅ›Ä‡ okna przeglÄ…darki
function useWindowWidth() {
    // Ustawiamy poczÄ…tkowy stan szerokoÅ›ci na bieÅ¼Ä…cÄ… szerokoÅ›Ä‡ okna przeglÄ…darki
    const [width, setWidth] = useState(window.innerWidth);

    // UÅ¼ywamy useEffect, aby dodaÄ‡ i usunÄ…Ä‡ zdarzenie "resize" tylko raz, podczas montowania i odmontowywania hooka
    useEffect(() => {
        // Funkcja handleResize aktualizuje stan width na bieÅ¼Ä…cÄ… szerokoÅ›Ä‡ okna
        const handleResize = () => setWidth(window.innerWidth);
        
        // Dodajemy nasÅ‚uchiwanie zdarzenia "resize", aby wykrywaÄ‡ zmiany szerokoÅ›ci okna
        window.addEventListener('resize', handleResize);
        
        // Funkcja cleanup (sprzÄ…tajÄ…ca) usuwajÄ…ca nasÅ‚uchiwanie zdarzenia "resize", gdy komponent jest odmontowany
        return () => window.removeEventListener('resize', handleResize);
    }, []); // [] jako drugi argument oznacza, Å¼e efekt zostanie wykonany tylko raz po zamontowaniu komponentu

    // Hook zwraca bieÅ¼Ä…cÄ… szerokoÅ›Ä‡ okna przeglÄ…darki
    return width;
}

// Komponent, ktÃ³ry korzysta z wÅ‚asnego hooka useWindowWidth
function WindowWidthDisplay() {
    // WywoÅ‚ujemy useWindowWidth, aby uzyskaÄ‡ aktualnÄ… szerokoÅ›Ä‡ okna
    const width = useWindowWidth();
    
    // Renderujemy element &lt;p&gt; z bieÅ¼Ä…cÄ… szerokoÅ›ciÄ… okna przeglÄ…darki
    return &lt;p&gt;SzerokoÅ›Ä‡ okna: {width}px&lt;/p&gt;;
}
        </code></pre>

        <!-- Wizualizacja wÅ‚asnego hooka -->
        <details>
          <summary class="viz-title">ğŸ“ˆ Wizualizacja dziaÅ‚ania: <strong>useWindowWidth (custom hook)</strong></summary>
          <div class="viz-wrap">
            <svg viewBox="0 0 1000 500" class="viz-svg">
              <defs>
                <marker id="arrow3" markerWidth="12" markerHeight="12" refX="10" refY="6" orient="auto">
                  <path d="M0,0 L12,6 L0,12 Z" fill="#94a3b8"></path>
                </marker>
              </defs>

              <g class="lane" transform="translate(10,10)">
                <rect width="480" height="480" rx="12"></rect>
                <text x="16" y="28" class="lane-title">WnÄ™trze hooka (useWindowWidth)</text>

                <g class="node" transform="translate(20,60)">
                  <rect width="440" height="54" rx="10"></rect>
                  <text x="12" y="22">const [width, setWidth] = useState(window.innerWidth)</text>
                  <text x="12" y="40" class="muted">poczÄ…tkowy stan</text>
                </g>

                <g class="node" transform="translate(20,130)">
                  <rect width="440" height="54" rx="10"></rect>
                  <text x="12" y="22">useEffect(() =&gt; {{ addEventListener('resize', handleResize) }}</text>
                  <text x="12" y="40" class="muted">subskrypcja resize</text>
                </g>

                <g class="pill" transform="translate(20,200)">
                  <rect width="440" height="54" rx="10"></rect>
                  <text x="12" y="32">handleResize =&gt; setWidth(window.innerWidth)</text>
                </g>

                <g class="warn" transform="translate(20,270)">
                  <rect width="440" height="54" rx="10"></rect>
                  <text x="12" y="22">return () =&gt; removeEventListener('resize', handleResize)</text>
                  <text x="12" y="40" class="muted">sprzÄ…tanie</text>
                </g>

                <g class="ok" transform="translate(20,340)">
                  <rect width="440" height="54" rx="10"></rect>
                  <text x="12" y="32">return width</text>
                </g>
              </g>

              <g class="lane" transform="translate(510,10)">
                <rect width="480" height="480" rx="12"></rect>
                <text x="16" y="28" class="lane-title">Komponent uÅ¼ywajÄ…cy hooka</text>

                <g class="node" transform="translate(20,60)">
                  <rect width="440" height="54" rx="10"></rect>
                  <text x="12" y="22">const width = useWindowWidth()</text>
                  <text x="12" y="40" class="muted">pobiera wartoÅ›Ä‡ z hooka</text>
                </g>

                <g class="ok" transform="translate(20,130)">
                  <rect width="440" height="54" rx="10"></rect>
                  <text x="12" y="32">&lt;p&gt;SzerokoÅ›Ä‡ okna: { '{width}' }px&lt;/p&gt;</text>
                </g>

                <g class="node" transform="translate(20,210)">
                  <rect width="440" height="54" rx="10"></rect>
                  <text x="12" y="22">Zdarzenie: window.resize</text>
                  <text x="12" y="40" class="muted">triggeruje handleResize</text>
                </g>

                <g class="pill" transform="translate(20,280)">
                  <rect width="440" height="54" rx="10"></rect>
                  <text x="12" y="32">setWidth(...) â†’ re-render komponentu</text>
                </g>

                <g class="ok" transform="translate(20,350)">
                  <rect width="440" height="54" rx="10"></rect>
                  <text x="12" y="32">UI pokazuje nowÄ… szerokoÅ›Ä‡</text>
                </g>
              </g>
            </svg>

            <div class="grid-two">
              <table class="db-table">
                <caption class="mini">Stan poczÄ…tkowy</caption>
                <thead><tr><th>width</th></tr></thead>
                <tbody><tr><td>np. 1366</td></tr></tbody>
              </table>
              <table class="db-table">
                <caption class="mini">Po zmianie rozmiaru okna</caption>
                <thead><tr><th>width</th></tr></thead>
                <tbody><tr><td>np. 1024</td></tr></tbody>
              </table>
            </div>
          </div>
        </details>

        <p><em>Idea:</em> hook â€pakujeâ€ logikÄ™ subskrypcji i aktualizacji w jednÄ… funkcjÄ™, ktÃ³rÄ… potem uÅ¼ywasz w wielu komponentach.</p>
   
   
              <hr style="margin:2rem 0;border:0;border-top:1px solid #1f2937" />

      <h2>useMemo vs useCallback (prosto + analogia)</h2>

      <p><strong>Analogia:</strong> WyobraÅº sobie kuchniÄ™.</p>
      <ul>
        <li><strong>useMemo</strong> = gotowe <em>danie</em> odÅ‚oÅ¼one do lodÃ³wki. Raz je liczysz/gotujesz, a potem bierzesz gotowy wynik, dopÃ³ki skÅ‚adniki siÄ™ nie zmieniÄ….</li>
        <li><strong>useCallback</strong> = kartka z <em>przepisem</em>. To ta sama kartka (ta sama referencja), wiÄ™c pomocnik (dziecko/komponent potomny) nie myÅ›li, Å¼e masz nowy przepis przy kaÅ¼dym wejÅ›ciu do kuchni.</li>
      </ul>

      <table class="db-table">
        <thead>
          <tr><th>Cecha</th><th>useMemo</th><th>useCallback</th></tr>
        </thead>
        <tbody>
          <tr><td>Co zapamiÄ™tuje?</td><td>Wynik obliczeÅ„ (wartoÅ›Ä‡)</td><td>SamÄ… funkcjÄ™ (referencjÄ™)</td></tr>
          <tr><td>Kiedy uÅ¼ywaÄ‡?</td><td>Gdy obliczenia sÄ… kosztowne lub wynik jest uÅ¼ywany wielokrotnie</td><td>Gdy przekazujesz funkcjÄ™ do dzieci (np. z <code>React.memo</code>) lub do zaleÅ¼noÅ›ci efektÃ³w</td></tr>
          <tr><td>Sygnatura</td><td><code>useMemo(() =&gt; wynik, [deps])</code></td><td><code>useCallback(() =&gt; fn, [deps])</code></td></tr>
          <tr><td>PuÅ‚apka</td><td>Nie ma sensu dla banalnych obliczeÅ„</td><td>Nie ma sensu, jeÅ›li dziecko i tak siÄ™ zawsze renderuje</td></tr>
        </tbody>
      </table>

      <div class="grid-two">
        <div>
          <h3>PrzykÅ‚ad 1 â€“ <code>useMemo</code> (zapamiÄ™taj wynik)</h3>
          <p>Liczymy sumÄ™ koszyka tylko, gdy zmieni siÄ™ lista pozycji.</p>
          <pre><code class="language-javascript">
import React, { useMemo, useState } from 'react';

function CartTotal({ items }) {
  // items: [{ price: number, qty: number }]
  const total = useMemo(() =&gt; {
    // Tu moÅ¼e byÄ‡ drogie liczenie (filtrowanie, sortowanie, redukcja)
    return items.reduce((sum, it) =&gt; sum + it.price * it.qty, 0);
  }, [items]);

  return (
    &lt;p&gt;Suma: {total.toFixed(2)} zÅ‚&lt;/p&gt;
  );
}
          </code></pre>
          <details open>
  <summary class="viz-title">ğŸ“ˆ Wizualizacja dziaÅ‚ania: <strong>useMemo â€“ CartTotal</strong></summary>
  <div class="viz-wrap">
    <svg viewBox="0 0 1000 420" class="viz-svg">
      <defs>
        <marker id="arrow" markerWidth="12" markerHeight="12" refX="10" refY="6" orient="auto">
          <path d="M0,0 L12,6 L0,12 Z" fill="#94a3b8"></path>
        </marker>
      </defs>

      <!-- Lewy tor: zmiana deps â†’ przelicz -->
      <g class="lane" transform="translate(10,10)">
        <rect width="480" height="400" rx="12"></rect>
        <text x="16" y="28" class="lane-title">Gdy <tspan class="muted">items</tspan> siÄ™ zmienia</text>

        <g class="node" transform="translate(20,60)">
          <rect width="440" height="54" rx="10"></rect>
          <text x="12" y="22">Render â†’ useMemo(fn, [items])</text>
          <text x="12" y="40" class="muted">porÃ³wnanie zaleÅ¼noÅ›ci</text>
        </g>

        <path d="M240,114 L240,148" class="arrow"/>
        <g class="warn" transform="translate(20,150)">
          <rect width="440" height="54" rx="10"></rect>
          <text x="12" y="22">deps ZMIENIONE â†’ uruchom fn()</text>
          <text x="12" y="40" class="muted">liczymy sumÄ™ koszyka</text>
        </g>

        <path d="M240,204 L240,238" class="arrow"/>
        <g class="pill" transform="translate(20,240)">
          <rect width="440" height="54" rx="10"></rect>
          <text x="12" y="22">total = items.reduce(...)</text>
          <text x="12" y="40" class="muted">zapisz w pamiÄ™ci (cache)</text>
        </g>

        <path d="M240,294 L240,328" class="arrow"/>
        <g class="ok" transform="translate(20,330)">
          <rect width="440" height="54" rx="10"></rect>
          <text x="12" y="22">UI: â€Suma: {total} zÅ‚â€</text>
          <text x="12" y="40" class="muted">uÅ¼ycie nowego wyniku</text>
        </g>
      </g>

      <!-- Prawy tor: brak zmiany deps â†’ uÅ¼yj cache -->
      <g class="lane" transform="translate(510,10)">
        <rect width="480" height="400" rx="12"></rect>
        <text x="16" y="28" class="lane-title">Gdy <tspan class="muted">items</tspan> jest takie samo (referencja)</text>

        <g class="node" transform="translate(20,60)">
          <rect width="440" height="54" rx="10"></rect>
          <text x="12" y="22">Render â†’ useMemo(fn, [items])</text>
          <text x="12" y="40" class="muted">zaleÅ¼noÅ›ci bez zmian</text>
        </g>

        <path d="M240,114 L240,148" class="arrow"/>
        <g class="ok" transform="translate(20,150)">
          <rect width="440" height="54" rx="10"></rect>
          <text x="12" y="22">ZwrÃ³Ä‡ WARTOÅšÄ† z cache</text>
          <text x="12" y="40" class="muted">fn nie jest wywoÅ‚ywana</text>
        </g>

        <path d="M240,204 L240,238" class="arrow"/>
        <g class="ok" transform="translate(20,240)">
          <rect width="440" height="54" rx="10"></rect>
          <text x="12" y="22">UI: â€Suma: {total} zÅ‚â€</text>
          <text x="12" y="40" class="muted">bez kosztownego liczenia</text>
        </g>
      </g>
    </svg>

    <div class="grid-two">
      <table class="db-table">
        <caption class="mini">Zmiana listy (nowa referencja)</caption>
        <thead><tr><th>items (ref)</th><th>total</th><th>przelicz?</th></tr></thead>
        <tbody><tr><td>0xA1 â†’ 0xB2</td><td>obliczony na nowo</td><td>TAK</td></tr></tbody>
      </table>
      <table class="db-table">
        <caption class="mini">Brak zmiany (ta sama referencja)</caption>
        <thead><tr><th>items (ref)</th><th>total</th><th>przelicz?</th></tr></thead>
        <tbody><tr><td>0xA1 â†’ 0xA1</td><td>z cache</td><td>NIE</td></tr></tbody>
      </table>
    </div>

    <p class="small">Uwaga: jeÅ›li â€mutujeszâ€ tablicÄ™ bez zmiany referencji (np. <code>push</code>), <code>useMemo</code> moÅ¼e siÄ™ nie przeliczyÄ‡ â€“ przekazuj nowÄ… tablicÄ™.</p>
  </div>
</details>
        </div>
        
<br>
        <div>
          <h3>PrzykÅ‚ad 2 â€“ <code>useCallback</code> (zapamiÄ™taj funkcjÄ™)</h3>
          <p>Przekazujemy stabilny handler do dziecka, Å¼eby <code>React.memo</code> mÃ³gÅ‚ pominÄ…Ä‡ zbÄ™dny render.</p>
          <pre><code class="language-javascript">
import React, { useCallback } from 'react';

const AddButton = React.memo(function AddButton({ onClick }) {
  return &lt;button onClick={onClick}&gt;Dodaj&lt;/button&gt;;
});

function ProductRow({ productId, onAdd }) {
  // Bez useCallback ta funkcja byÅ‚aby tworzona na nowo przy kaÅ¼dym renderze.
  const handleAdd = useCallback(() =&gt; {
    onAdd(productId);
  }, [onAdd, productId]);

  return (
    &lt;div&gt;
      &lt;span&gt;Produkt {productId}&lt;/span&gt;
      &lt;AddButton onClick={handleAdd} /&gt;
    &lt;/div&gt;
  );
}
          </code></pre>
        </div>
        
      </div>
      <details>
  <summary class="viz-title">ğŸ“ˆ Wizualizacja dziaÅ‚ania: <strong>useCallback â€“ ProductRow / AddButton</strong></summary>
  <div class="viz-wrap">
    <svg viewBox="0 0 1000 500" class="viz-svg">
      <defs>
        <marker id="arrow2" markerWidth="12" markerHeight="12" refX="10" refY="6" orient="auto">
          <path d="M0,0 L12,6 L0,12 Z" fill="#94a3b8"></path>
        </marker>
      </defs>

      <!-- Rodzic -->
      <g class="lane" transform="translate(10,10)">
        <rect width="480" height="480" rx="12"></rect>
        <text x="16" y="28" class="lane-title">Komponent rodzic â€“ stabilna funkcja</text>

        <g class="node" transform="translate(20,60)">
          <rect width="440" height="54" rx="10"></rect>
          <text x="12" y="22">const handleAdd = useCallback(() =&gt; onAdd(productId), [onAdd, productId])</text>
          <text x="12" y="40" class="muted">tworzy/utrzymuje referencjÄ™</text>
        </g>

        <path d="M240,114 L240,148" class="arrow2"/>
        <g class="ok" transform="translate(20,150)">
          <rect width="440" height="54" rx="10"></rect>
          <text x="12" y="22">Gdy deps BEZ zmian â†’ ta SAMA referencja</text>
          <text x="12" y="40" class="muted">handleAdd === poprzedni</text>
        </g>

        <path d="M240,204 L240,238" class="arrow2"/>
        <g class="warn" transform="translate(20,240)">
          <rect width="440" height="54" rx="10"></rect>
          <text x="12" y="22">Gdy deps ZMIENIONE â†’ NOWA referencja</text>
          <text x="12" y="40" class="muted">odÅ›wieÅ¼ prop dla dziecka</text>
        </g>

        <path d="M240,294 L240,328" class="arrow2"/>
        <g class="node" transform="translate(20,330)">
          <rect width="440" height="54" rx="10"></rect>
          <text x="12" y="22">&lt;AddButton onClick={handleAdd} /&gt;</text>
          <text x="12" y="40" class="muted">przekazanie do dziecka</text>
        </g>
      </g>

      <!-- Dziecko (React.memo) -->
      <g class="lane" transform="translate(510,10)">
        <rect width="480" height="480" rx="12"></rect>
        <text x="16" y="28" class="lane-title">Dziecko â€“ <tspan class="muted">React.memo</tspan></text>

        <g class="node" transform="translate(20,60)">
          <rect width="440" height="54" rx="10"></rect>
          <text x="12" y="22">PorÃ³wnanie props (pÅ‚ytkie)</text>
          <text x="12" y="40" class="muted">onClick: ref stara vs nowa</text>
        </g>

        <path d="M240,114 L240,148" class="arrow2"/>
        <g class="ok" transform="translate(20,150)">
          <rect width="440" height="54" rx="10"></rect>
          <text x="12" y="22">Ta sama referencja â†’ POMIÅƒ render</text>
          <text x="12" y="40" class="muted">optimum zachowane</text>
        </g>

        <path d="M240,204 L240,238" class="arrow2"/>
        <g class="warn" transform="translate(20,240)">
          <rect width="440" height="54" rx="10"></rect>
          <text x="12" y="22">Nowa referencja â†’ RENDER dziecka</text>
          <text x="12" y="40" class="muted">bo props siÄ™ zmieniÅ‚</text>
        </g>

        <path d="M240,294 L240,328" class="arrow2"/>
        <g class="node" transform="translate(20,330)">
          <rect width="440" height="54" rx="10"></rect>
          <text x="12" y="22">&lt;button onClick={onClick}&gt;Dodaj&lt;/button&gt;</text>
          <text x="12" y="40" class="muted">klik â†’ onAdd(productId)</text>
        </g>
      </g>
    </svg>

    <div class="grid-two">
      <table class="db-table">
        <caption class="mini">2 kolejne rendery (bez zmian deps)</caption>
        <thead><tr><th>render</th><th>handleAdd ref</th><th>dziecko re-render?</th></tr></thead>
        <tbody>
          <tr><td>R1</td><td>0xF0</td><td>TAK (pierwszy raz)</td></tr>
          <tr><td>R2</td><td>0xF0 (ta sama)</td><td>NIE</td></tr>
        </tbody>
      </table>
      <table class="db-table">
        <caption class="mini">Zmiana deps (np. inny productId)</caption>
        <thead><tr><th>render</th><th>handleAdd ref</th><th>dziecko re-render?</th></tr></thead>
        <tbody>
          <tr><td>R3</td><td>0xAB (nowa)</td><td>TAK</td></tr>
        </tbody>
      </table>
    </div>

    <p class="small">Tip: jeÅ›li dziecko i tak zawsze siÄ™ renderuje, <code>useCallback</code> nie da zysku. Zyski sÄ… gÅ‚Ã³wnie z <code>React.memo</code> / memoized props.</p>
  </div>
</details>

      <ul>
        <li><strong>UÅ¼yj <code>useMemo</code></strong>, gdy wynik liczenia jest kosztowny albo wykorzystywany w wielu miejscach (np. filtrowanie duÅ¼ych list, agregacje).</li>
        <li><strong>UÅ¼yj <code>useCallback</code></strong>, gdy funkcjÄ™ przekazujesz do komponentÃ³w potomnych optymalizowanych przez <code>React.memo</code> lub gdy trafia do tablicy zaleÅ¼noÅ›ci w <code>useEffect</code>/<code>useMemo</code>/<code>useCallback</code>.</li>
      </ul>

      <p><strong>ReguÅ‚a na skrÃ³ty:</strong> jeÅ›li chcesz â€zapamiÄ™taÄ‡ liczbÄ™/tablicÄ™/obiektâ€ â†’ <code>useMemo</code>. JeÅ›li chcesz â€zapamiÄ™taÄ‡ handlerâ€ â†’ <code>useCallback</code>.</p>

    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-javascript.min.js"></script>

    <!-- Lekki, izolowany CSS tylko dla wizualizacji -->
    <style>
      .viz-title{cursor:pointer;font-weight:600}
      .viz-wrap{padding:.5rem .25rem}
      .viz-svg{width:100%;height:auto;background:#0e1729;border-radius:12px}
      .lane rect{fill:#0f172a;stroke:#1f2937}
      .lane-title{fill:#cbd5e1;font-weight:600}
      .node rect{fill:#111827;stroke:#334155}
      .pill rect{fill:#0b3b2e;stroke:#14532d}
      .ok rect{fill:#0b2a3b;stroke:#0e7490}
      .warn rect{fill:#3b0b0b;stroke:#7f1d1d}
      .node text,.pill text,.ok text,.warn text{fill:#e2e8f0;font-size:14px}
      .muted{fill:#94a3b8;font-size:12px}
      .arrow{stroke:#94a3b8;stroke-width:2;fill:none;marker-end:url(#arrow)}
      .arrow2{stroke:#94a3b8;stroke-width:2;fill:none;marker-end:url(#arrow2)}
      .arrow3{stroke:#94a3b8;stroke-width:2;fill:none;marker-end:url(#arrow3)}
      .db-table{width:100%;border-collapse:collapse;margin:.5rem 0}
      .db-table th,.db-table td{border:1px solid #aeaeae;padding:.5rem .65rem;text-align:left;vertical-align:top}
      .db-table th{background:#0e1729;color:#dbe2ea}
  
      @media (max-width: 900px){.grid-two{grid-template-columns:1fr}}
    </style>
</body>
</html>
