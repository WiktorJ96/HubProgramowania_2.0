<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>React - Props i State</title>
    <link rel="stylesheet" href="../styles.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
</head>
<body>
    <div class="container">
        <h1>React - Props i State</h1>
        
        <p>W React moÅ¼emy przekazywaÄ‡ dane miÄ™dzy komponentami przy pomocy <code>props</code> oraz zarzÄ…dzaÄ‡ stanem komponentÃ³w przy uÅ¼yciu <code>state</code>. Oto podstawy, ktÃ³re pozwolÄ… zrozumieÄ‡, jak te mechanizmy dziaÅ‚ajÄ….</p>

        <h2>Props</h2>
        <p><code>Props</code> to wÅ‚aÅ›ciwoÅ›ci przekazywane od komponentu nadrzÄ™dnego (rodzica) do komponentu podrzÄ™dnego (dziecka). UÅ¼ywamy ich, aby przekazaÄ‡ dane lub funkcje do komponentÃ³w dzieci, ktÃ³re nie mogÄ… samodzielnie zmieniÄ‡ wartoÅ›ci przekazanych <code>props</code>.</p>

        <pre><code class="language-javascript">
// Komponent rodzica
function ParentComponent() {
    return &lt;ChildComponent message="Witaj, Å›wiecie!" /&gt;;
}

// Komponent dziecka
function ChildComponent(props) {
    return &lt;h1&gt;{props.message}&lt;/h1&gt;;
}
        </code></pre>

        <!-- Wizualizacja: przepÅ‚yw props Parent -> Child -->
        <details open>
          <summary class="viz-title">ğŸ§­ Wizualizacja â€Propsâ€ â€“ przepÅ‚yw danych rodzic âœ dziecko</summary>
          <div class="viz-wrap">
            <svg viewBox="0 0 1000 340" class="viz-svg" aria-label="Diagram przepÅ‚ywu props">
              <defs>
                <marker id="arrowProps" markerWidth="12" markerHeight="12" refX="10" refY="6" orient="auto">
                  <path d="M0,0 L12,6 L0,12 Z" fill="#94a3b8"></path>
                </marker>
              </defs>

              <g class="lane" transform="translate(10,10)">
                <rect width="980" height="320" rx="12"></rect>
                <text x="16" y="28" class="lane-title">ParentComponent (render) â†’ ChildComponent(props) â†’ UI</text>

                <g class="node" transform="translate(20,60)">
                  <rect width="280" height="70" rx="10"></rect>
                  <text x="12" y="28">&lt;ChildComponent message="Witaj, Å›wiecie!" /&gt;</text>
                  <text x="12" y="50" class="muted">JSX w rodzicu</text>
                </g>

                <path d="M300,95 L360,95" class="arrowP"/>
                <g class="ok" transform="translate(360,60)">
                  <rect width="300" height="70" rx="10"></rect>
                  <text x="12" y="28">Tworzenie props {"{ message: 'Witaj, Å›wiecie!' }"}</text>
                  <text x="12" y="50" class="muted">React buduje obiekt props</text>
                </g>

                <path d="M660,95 L720,95" class="arrowP"/>
                <g class="node" transform="translate(720,60)">
                  <rect width="250" height="70" rx="10"></rect>
                  <text x="12" y="28">ChildComponent(props)</text>
                  <text x="12" y="50" class="muted">odczyt: props.message</text>
                </g>

                <g class="pill" transform="translate(360,160)">
                  <rect width="610" height="70" rx="10"></rect>
                  <text x="12" y="28">Zwracany JSX: &lt;h1&gt;Witaj, Å›wiecie!&lt;/h1&gt;</text>
                  <text x="12" y="50" class="muted">renderer â†’ DOM</text>
                </g>
              </g>
            </svg>

            <div class="grid-two">
              <table class="db-table">
                <caption class="mini">Zasady props</caption>
                <thead><tr><th>Cecha</th><th>Opis</th></tr></thead>
                <tbody>
                  <tr><td>Kierunek</td><td>Jednokierunkowy: rodzic âœ dziecko</td></tr>
                  <tr><td>Modyfikacja</td><td>Dziecko <em>nie</em> zmienia props</td></tr>
                  <tr><td>Cel</td><td>Przekaz danych/handlerÃ³w</td></tr>
                </tbody>
              </table>
              <table class="db-table">
                <caption class="mini">AnalogiÄ…</caption>
                <thead><tr><th>Rola</th><th>PorÃ³wnanie</th></tr></thead>
                <tbody>
                  <tr><td>Rodzic</td><td>Nauczyciel daje kartkÄ™ z tekstem</td></tr>
                  <tr><td>Dziecko</td><td>Odczytuje i wyÅ›wietla</td></tr>
                </tbody>
              </table>
            </div>
          </div>
        </details>

        <p>W powyÅ¼szym przykÅ‚adzie komponent rodzica <code>ParentComponent</code> przekazuje wartoÅ›Ä‡ <code>"Witaj, Å›wiecie!"</code> do komponentu dziecka <code>ChildComponent</code> za pomocÄ… mechanizmu <code>props</code>. W React <code>props</code> pozwala na przesyÅ‚anie danych miÄ™dzy komponentami, umoÅ¼liwiajÄ…c komponentowi nadrzÄ™dnemu (rodzicowi) przekazanie informacji do komponentu podrzÄ™dnego (dziecka).</p>
        <p>W <code>ParentComponent</code> wartoÅ›Ä‡ <code>"Witaj, Å›wiecie!"</code> jest przypisana do atrybutu JSX o nazwie <code>message</code>. W momencie renderowania React automatycznie tworzy obiekt <code>props</code> dla <code>ChildComponent</code>, zawierajÄ…cy wszystkie przekazane atrybuty. W tym przypadku <code>props</code> zawiera wÅ‚aÅ›ciwoÅ›Ä‡ <code>message</code> z wartoÅ›ciÄ… <code>"Witaj, Å›wiecie!"</code>.</p>
        <p>W <code>ChildComponent</code> dostÄ™p do <code>props</code> uzyskujemy poprzez argument funkcji. Komponent dziecka moÅ¼e odczytaÄ‡ wartoÅ›Ä‡ przekazanÄ… z rodzica, wywoÅ‚ujÄ…c <code>props.message</code>. Ta wartoÅ›Ä‡ jest nastÄ™pnie wyÅ›wietlana wewnÄ…trz elementu <code>&lt;h1&gt;</code>, co powoduje renderowanie tekstu <code>"Witaj, Å›wiecie!"</code> na stronie.</p>

        <h2>State</h2>
        <p><code>State</code> jest wewnÄ™trznym stanem komponentu, ktÃ³ry moÅ¼e byÄ‡ zmieniany w trakcie jego cyklu Å¼ycia. Zmiana stanu powoduje ponowne renderowanie komponentu, aby zaktualizowaÄ‡ jego wyglÄ…d lub dane wyÅ›wietlane w interfejsie.</p>

        <pre><code class="language-javascript">
import React, { useState } from 'react';

function Counter() {
    const [count, setCount] = useState(0); // Inicjalizacja stanu z wartoÅ›ciÄ… poczÄ…tkowÄ… 0

    return (
        &lt;div&gt;
            &lt;p&gt;Licznik: {count}&lt;/p&gt;
            &lt;button onClick={() =&gt; setCount(count + 1)}&gt;ZwiÄ™ksz&lt;/button&gt;
        &lt;/div&gt;
    );
}
        </code></pre>

        <!-- Wizualizacja: cykl setState -> kolejka -> re-render -->
        <details>
          <summary class="viz-title">â±ï¸ Wizualizacja â€Stateâ€ â€“ aktualizacja i render</summary>
          <div class="viz-wrap">
            <svg viewBox="0 0 1000 420" class="viz-svg" aria-label="Diagram aktualizacji state">
              <defs>
                <marker id="arrowState" markerWidth="12" markerHeight="12" refX="10" refY="6" orient="auto">
                  <path d="M0,0 L12,6 L0,12 Z" fill="#94a3b8"></path>
                </marker>
              </defs>

              <g class="lane" transform="translate(10,10)">
                <rect width="980" height="400" rx="12"></rect>
                <text x="16" y="28" class="lane-title">Klik â†’ setCount(n+1) â†’ kolejka aktualizacji â†’ nowy render â†’ UI</text>

                <g class="node" transform="translate(20,60)">
                  <rect width="280" height="70" rx="10"></rect>
                  <text x="12" y="28">Stan poczÄ…tkowy</text>
                  <text x="12" y="50" class="muted">count = 0</text>
                </g>

                <path d="M300,95 L360,95" class="arrowS"/>
                <g class="ok" transform="translate(360,60)">
                  <rect width="280" height="70" rx="10"></rect>
                  <text x="12" y="28">onClick â†’ setCount(count+1)</text>
                  <text x="12" y="50" class="muted">dodanie do kolejki</text>
                </g>

                <path d="M640,95 L700,95" class="arrowS"/>
                <g class="pill" transform="translate(700,60)">
                  <rect width="270" height="70" rx="10"></rect>
                  <text x="12" y="28">Batching</text>
                  <text x="12" y="50" class="muted">scalenie wielu setState</text>
                </g>

                <g class="node" transform="translate(360,160)">
                  <rect width="610" height="70" rx="10"></rect>
                  <text x="12" y="28">Obliczenie nowego stanu</text>
                  <text x="12" y="50" class="muted">count = 1</text>
                </g>

                <g class="ok" transform="translate(20,250)">
                  <rect width="950" height="70" rx="10"></rect>
                  <text x="12" y="28">Nowy render komponentu</text>
                  <text x="12" y="50" class="muted">UI: â€Licznik: 1â€</text>
                </g>
              </g>
            </svg>

            <div class="grid-two">
              <table class="db-table">
                <caption class="mini">WaÅ¼ne fakty</caption>
                <thead><tr><th>Co</th><th>Dlaczego</th></tr></thead>
                <tbody>
                  <tr><td>AsynchronicznoÅ›Ä‡</td><td>React Å‚Ä…czy aktualizacje (batching)</td></tr>
                  <tr><td>Re-render</td><td>nastÄ™puje po zmianie stanu</td></tr>
                  <tr><td>Funkcyjny set</td><td><code>setCount(c =&gt; c+1)</code> bezpieczny przy wielu klikach</td></tr>
                </tbody>
              </table>

              <table class="db-table">
                <caption class="mini">Anti-patterny</caption>
                <thead><tr><th>Co unikaÄ‡</th><th>Dlaczego</th></tr></thead>
                <tbody>
                  <tr><td>BezpoÅ›rednia modyfikacja</td><td>np. <code>count++</code> nie zmienia UI</td></tr>
                  <tr><td>Wielokrotne set na podstawie starego <code>count</code></td><td>uÅ¼yj funkcji: <code>setCount(c =&gt; c+1)</code></td></tr>
                </tbody>
              </table>
            </div>
          </div>
        </details>

        <p>W powyÅ¼szym przykÅ‚adzie uÅ¼yto funkcji <code>useState</code>, aby utworzyÄ‡ stan o nazwie <code>count</code> i przypisaÄ‡ mu wartoÅ›Ä‡ poczÄ…tkowÄ… 0. <code>useState</code> to funkcja React, ktÃ³ra pozwala komponentowi na przechowywanie i zarzÄ…dzanie danymi, ktÃ³re mogÄ… siÄ™ zmieniaÄ‡ w trakcie dziaÅ‚ania aplikacji. Funkcja ta zwraca tablicÄ™ dwÃ³ch elementÃ³w: aktualnÄ… wartoÅ›Ä‡ stanu (<code>count</code>) i funkcjÄ™ do aktualizacji tego stanu.</p>
        <p>Kiedy uÅ¼ytkownik kliknie przycisk, wywoÅ‚ywana jest funkcja, ktÃ³ra zwiÄ™ksza wartoÅ›Ä‡ <code>count</code> o 1, uÅ¼ywajÄ…c funkcji aktualizujÄ…cej stan (zwrÃ³conej przez <code>useState</code>). DziÄ™ki temu komponent zostaje ponownie wyrenderowany z nowÄ…, zwiÄ™kszonÄ… wartoÅ›ciÄ… <code>count</code>.</p>
        <p>PodsumowujÄ…c: <code>useState</code> umoÅ¼liwia komponentowi przechowywanie dynamicznych danych, a kaÅ¼da zmiana tych danych powoduje ponowne wyrenderowanie komponentu, aby wyÅ›wietliÄ‡ aktualnÄ… wartoÅ›Ä‡.</p>

        <h2>Props i State razem</h2>
        <p>MoÅ¼emy takÅ¼e Å‚Ä…czyÄ‡ <code>props</code> i <code>state</code>, przekazujÄ…c stan komponentu rodzica jako <code>props</code> do komponentu dziecka. To pozwala na kontrolowanie stanu przez komponent nadrzÄ™dny i aktualizacjÄ™ widoku komponentu podrzÄ™dnego.</p>

        <pre><code class="language-javascript">
// Komponent rodzica
function ParentComponent() {
    const [message, setMessage] = useState("PoczÄ…tkowa wiadomoÅ›Ä‡");

    return (
        &lt;div&gt;
            &lt;ChildComponent message={message} /&gt;
            &lt;button onClick={() =&gt; setMessage("Zaktualizowana wiadomoÅ›Ä‡")} &gt;ZmieÅ„ wiadomoÅ›Ä‡&lt;/button&gt;
        &lt;/div&gt;
    );
}

// Komponent dziecka
function ChildComponent(props) {
    return &lt;h1&gt;{props.message}&lt;/h1&gt;;
}
        </code></pre>

        <!-- Wizualizacja: rodzic kontroluje dziecko poprzez props -->
        <details>
          <summary class="viz-title">ğŸ”— Wizualizacja â€Props + Stateâ€ â€“ rodzic steruje dzieckiem</summary>
          <div class="viz-wrap">
            <svg viewBox="0 0 1000 460" class="viz-svg" aria-label="Diagram props + state">
              <defs>
                <marker id="arrowPS" markerWidth="12" markerHeight="12" refX="10" refY="6" orient="auto">
                  <path d="M0,0 L12,6 L0,12 Z" fill="#94a3b8"></path>
                </marker>
              </defs>

              <g class="lane" transform="translate(10,10)">
                <rect width="980" height="440" rx="12"></rect>
                <text x="16" y="28" class="lane-title">Parent: state(message) â†’ props â†’ Child â†’ UI (klik = setMessage = nowy render)</text>

                <g class="node" transform="translate(20,60)">
                  <rect width="320" height="70" rx="10"></rect>
                  <text x="12" y="28">Parent useState</text>
                  <text x="12" y="50" class="muted">message = "PoczÄ…tkowa wiadomoÅ›Ä‡"</text>
                </g>

                <path d="M340,95 L400,95" class="arrowPS"/>
                <g class="ok" transform="translate(400,60)">
                  <rect width="280" height="70" rx="10"></rect>
                  <text x="12" y="28">Przekazanie props</text>
                  <text x="12" y="50" class="muted">{ message }</text>
                </g>

                <path d="M680,95 L740,95" class="arrowPS"/>
                <g class="node" transform="translate(740,60)">
                  <rect width="230" height="70" rx="10"></rect>
                  <text x="12" y="28">Child render</text>
                  <text x="12" y="50" class="muted">&lt;h1&gt;{message}&lt;/h1&gt;</text>
                </g>

                <g class="pill" transform="translate(400,160)">
                  <rect width="570" height="70" rx="10"></rect>
                  <text x="12" y="28">UI pokazuje: â€PoczÄ…tkowa wiadomoÅ›Ä‡â€</text>
                  <text x="12" y="50" class="muted">props sterujÄ… wyjÅ›ciem</text>
                </g>

                <g class="warn" transform="translate(20,250)">
                  <rect width="950" height="70" rx="10"></rect>
                  <text x="12" y="28">Klik: setMessage("Zaktualizowana wiadomoÅ›Ä‡")</text>
                  <text x="12" y="50" class="muted">nowy stan w rodzicu</text>
                </g>

                <g class="ok" transform="translate(20,330)">
                  <rect width="950" height="70" rx="10"></rect>
                  <text x="12" y="28">Nowy render â†’ nowe props â†’ nowe UI</text>
                  <text x="12" y="50" class="muted">â€Zaktualizowana wiadomoÅ›Ä‡â€</text>
                </g>
              </g>
            </svg>

            <div class="grid-two">
              <table class="db-table">
                <caption class="mini">Wzorzec â€kontrolowanyâ€</caption>
                <thead><tr><th>Element</th><th>Rola</th></tr></thead>
                <tbody>
                  <tr><td>Rodzic</td><td>posiada stan, zmienia go</td></tr>
                  <tr><td>Dziecko</td><td>wyÅ›wietla to, co dostaÅ‚o w props</td></tr>
                </tbody>
              </table>
              <table class="db-table">
                <caption class="mini">CzÄ™ste bÅ‚Ä™dy</caption>
                <thead><tr><th>Problem</th><th>Jak naprawiÄ‡</th></tr></thead>
                <tbody>
                  <tr><td>Dziecko prÃ³buje zmieniÄ‡ props</td><td>zamiast tego wywoÅ‚uj handler z rodzica</td></tr>
                  <tr><td>Desynchronizacja</td><td>ÅºrÃ³dÅ‚o prawdy = stan rodzica</td></tr>
                </tbody>
              </table>
            </div>
          </div>
        </details>

        <p>W tym przykÅ‚adzie <code>ParentComponent</code> dziaÅ‚a jak nauczyciel, ktÃ³ry zarzÄ…dza tablicÄ… (stanem <code>message</code>) i przekazuje jej zawartoÅ›Ä‡ do <code>ChildComponent</code>, czyli ucznia, ktÃ³ry odczytuje tÄ™ wiadomoÅ›Ä‡. KlikniÄ™cie przycisku sprawia, Å¼e nauczyciel zmienia wiadomoÅ›Ä‡ na tablicy, co automatycznie powoduje, Å¼e uczeÅ„ widzi nowÄ… treÅ›Ä‡. DziÄ™ki temu <code>ChildComponent</code> zawsze pokazuje aktualnÄ… wiadomoÅ›Ä‡ przekazanÄ… z <code>ParentComponent</code>.</p>

        <h2>Podsumowanie</h2>
        <!-- Props -->
        <p><strong>Props:</strong></p>
        <ul>
          <li>Dane przekazywane z rodzica do dziecka jako argumenty.</li>
          <li>Tylko do odczytu (niemodyfikowalne przez komponent).</li>
        </ul>

        <!-- State -->
        <p><strong>State:</strong></p>
        <ul>
          <li>Lokalny stan komponentu, ktÃ³ry moÅ¼na modyfikowaÄ‡.</li>
          <li>UÅ¼ywany do dynamicznego zarzÄ…dzania danymi.</li>
          <li>W komponentach funkcyjnych zarzÄ…dzany za pomocÄ… hooka <code>useState</code>.</li>
        </ul>

    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-javascript.min.js"></script>

    <!-- Izolowany CSS dla wizualizacji: peÅ‚na szerokoÅ›Ä‡ + responsywnoÅ›Ä‡ -->
    <style>
      /* Upewnij siÄ™, Å¼e bloki korzystajÄ… z peÅ‚nej szerokoÅ›ci kontenera */
      details, .viz-wrap { width: 100%; max-width: none !important; }
      .viz-svg{display:block;width:100% !important;max-width:100% !important;height:auto !important;background:#0e1729;border-radius:12px}

      /* TytuÅ‚y i wrapper */
      .viz-title{cursor:pointer;font-weight:600}
      .viz-wrap{padding:.5rem .25rem}

      /* Siatka i tabelki */
      .grid-two{display:grid;grid-template-columns:minmax(0,1fr) minmax(0,1fr);gap:.75rem;width:100%;max-width:none}
      .grid-two>*{min-width:0}
      @media (max-width: 900px){.grid-two{grid-template-columns:1fr}}
      .db-table{width:100% !important;max-width:100% !important;border-collapse:collapse;margin:.5rem 0;table-layout:fixed}
      .db-table th,.db-table td{border:1px solid #aeaeae;padding:.5rem .65rem;text-align:left;vertical-align:top;word-break:break-word}
      .db-table th{background:#0e1729;color:#dbe2ea}
      .mini{color:#a7b0be;font-size:.95rem}

      /* Styl kafelkÃ³w w SVG */
      .lane rect{fill:#0f172a;stroke:#1f2937}
      .lane-title{fill:#cbd5e1;font-weight:600}
      .node rect{fill:#111827;stroke:#334155}
      .pill rect{fill:#0b3b2e;stroke:#14532d}
      .ok rect{fill:#0b2a3b;stroke:#0e7490}
      .warn rect{fill:#3b0b0b;stroke:#7f1d1d}
      .node text,.pill text,.ok text,.warn text{fill:#e2e8f0;font-size:14px}
      .muted{fill:#94a3b8;font-size:12px}

      /* StrzaÅ‚ki */
      .arrowP,.arrowS,.arrowPS{stroke:#94a3b8;stroke-width:2;fill:none}
      .arrowP{marker-end:url(#arrowProps)}
      .arrowS{marker-end:url(#arrowState)}
      .arrowPS{marker-end:url(#arrowPS)}

      /* Kod â€“ peÅ‚na szerokoÅ›Ä‡ + przewijanie */
      pre[class*="language-"]{width:100% !important;max-width:none !important;box-sizing:border-box;overflow-x:auto;white-space:pre}
      code[class*="language-"]{white-space:pre}
    </style>
</body>
</html>
